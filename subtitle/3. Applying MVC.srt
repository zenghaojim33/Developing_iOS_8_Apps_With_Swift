1
00:00:00,001 --> 00:00:04,636
[MUSIC]
音乐

2
00:00:04,638 --> 00:00:07,171
Stanford University.
斯坦福大学

3
00:00:09,809 --> 00:00:13,343
Okay, well welcome to
CS193p, Winter 2015.
好的,热烈欢迎来到CS193p 2015 冬季课程

4
00:00:13,345 --> 00:00:15,445
This is Lecture NO.3.
这是第三堂课.

5
00:00:15,447 --> 00:00:17,714
This is gonna be all demo.
这节课将全部是演示.

6
00:00:17,716 --> 00:00:21,283
today, my voice is mostly
recovered from last week,
跟上周比我今天的声音基本上恢复了,

7
00:00:21,285 --> 00:00:22,918
not 100% as you can tell.
但如你们听到的, 我并没有完全恢复.

8
00:00:22,920 --> 00:00:23,985
But it's getting there.
但是差不多了.

9
00:00:25,455 --> 00:00:29,924
So what we're gonna be doing
today is a demo.
好的, 我们今天将要进行一个演示.

10
00:00:29,926 --> 00:00:31,825
We're gonna extend our
calculator a little bit,
我们会给计算器加点东西

11
00:00:31,827 --> 00:00:33,460
we're gonna make it more
powerful.
让它功能更强大.

12
00:00:33,462 --> 00:00:36,629
But more importantly, we're
gonna have it obey this MVC
更重要的是, 我们将会让它遵从MVC

13
00:00:36,631 --> 00:00:37,930
design paradigm.
设计范例.

14
00:00:37,932 --> 00:00:39,682
'Kay?
好么?

15
00:00:39,683 --> 00:00:41,433
So it's good, a pretty good
example of showing how
因此, 这是一个演示如何把(计算器里的)内容

16
00:00:41,436 --> 00:00:44,670
we're gonna separate the stuff
into the camps here.
分配到这里列出的区块的好例子.

17
00:00:44,672 --> 00:00:46,138
Now, we're gonna cover a bunch
of other things,
现在我们要讲讲其他的, 比如

18
00:00:46,140 --> 00:00:48,473
language features and stuff as
I always do.
语言特性和用法这些惯例内容.

19
00:00:48,475 --> 00:00:52,143
That's really the primary goal
of these first three lectures
这是前三节有演示的课的最主要目标.

20
00:00:52,145 --> 00:00:54,078
with the demo.
我之所以向你们实时演示

21
00:00:54,079 --> 00:00:56,012
So I just mean for you to see
it in action because you can
我之所以将要向你们实时演示

22
00:00:56,015 --> 00:00:59,750
read all you want about swift
or, about iOS, but until you
是因为虽然你们能读到所有你们想读的关于swift或者iOS的内容

23
00:00:59,752 --> 00:01:02,619
actually see it act, turning
into an app, it's not real.
但直到你看到代码如何成为应用，才融会贯通.

24
00:01:02,621 --> 00:01:04,420
So I'm just trying to make it
real for you.
因此我会试着将应用的编写的过程展示给你们.

25
00:01:06,057 --> 00:01:08,590
I'm going to go to my last
slide, because,
我会讲完最后一张幻灯片, 因为,

26
00:01:08,592 --> 00:01:11,093
once I go to the demo, I'll
forget to come back.
我一旦开始做演示就停不下来了.

27
00:01:11,095 --> 00:01:13,895
Which is just the what's
coming up in this class.
这张幻灯片仅仅是说明接下来这门课要讲什么.

28
00:01:13,897 --> 00:01:17,031
On Wednesday, it's gonna be no
demo, it's gonna be all
本周三没有课上演示,全是幻灯片.

29
00:01:17,033 --> 00:01:19,967
slides, it's going to be one
of the few lectures where it's all slides
这种课不会多，但这节是其中之一.

30
00:01:21,186 --> 00:01:22,402
But what I'm gonna try to do,
我会在周三的课上尝试划出

31
00:01:22,405 --> 00:01:25,205
on Wednesday, is give you the
highlights of this all
划出你们

32
00:01:25,207 --> 00:01:27,307
this reading that you're doing.
现阶段所学重点.

33
00:01:27,309 --> 00:01:28,658
Okay?
Because you're
可以么？因为

34
00:01:28,659 --> 00:01:30,008
reading a lot of stuff and
it's sometimes hard to
你们要读很多的东西,有时候区分

35
00:01:30,011 --> 00:01:32,611
tell what's really important
in there and what's not.
哪些是重点哪些不是会比较困难.

36
00:01:32,613 --> 00:01:34,279
So I'm gonna kinda give you
the highlights so
因此我会给你们划重点.

37
00:01:34,281 --> 00:01:36,448
you can get an idea of what's
important.
这样你们会对重点内容有些概念.

38
00:01:36,450 --> 00:01:40,618
And then I'm also gonna start
talking about some of
接着我会开始讲一些

39
00:01:40,620 --> 00:01:45,255
the foundation layer API in
IOS that's the non,
iOS中基础层的非

40
00:01:45,257 --> 00:01:47,891
user interface layer basically and
用户界面 API, 大体上讲.

41
00:01:47,893 --> 00:01:51,227
kinda what some of the classes
are in there.
和其中包含的一些类.

42
00:01:51,229 --> 00:01:54,130
And then also just a little
bit of how we use the language
接着是一点点关于如何使用iOS中Swift

43
00:01:54,132 --> 00:01:57,099
features of swift, and
foundation, in iOS so
 和Foundation 框架的语言特性.

44
00:01:57,101 --> 00:02:00,169
that you can kinda get this
kind of your
这样在一定程度上

45
00:02:00,171 --> 00:02:01,870
next Wednesday's lecture ,
本周三的课

46
00:02:01,872 --> 00:02:03,772
is gonna be your baseline lecture,
会成为你的当做奠基课程.

47
00:02:03,774 --> 00:02:07,241
can kinda get you grounded in
how to do all this stuff.
你在一定程度会获得如何做这些东西的根基.

48
00:02:07,243 --> 00:02:10,044
And then next week we'll start
diving in,
然后接下来一周我们开始深入,

49
00:02:10,046 --> 00:02:13,814
to build a more sophisticated
iOS application.
写一个更成熟高端的iOS应用.

50
00:02:13,816 --> 00:02:15,682
Okay, I know this is kind of a
whirlwind in first two
好的, 我知道头两周会有些吃力,

51
00:02:15,684 --> 00:02:18,752
weeks, you're learning a new
language, all new system.
你们将在其间学一门新的编程语言, 一个全新的体系.

52
00:02:18,754 --> 00:02:20,920
But hopefully by the end of
this week and the end of your
但是希望在这周以及

53
00:02:20,922 --> 00:02:24,757
second assignment which will
go out on Wednesday you'll be
将在周三布置的第二个作业结束之后,

54
00:02:24,759 --> 00:02:26,225
pretty confident that you'll
at least,
你能够比较确信,至少自己,

55
00:02:26,227 --> 00:02:30,595
you know, have a, solid ground
foundation to build from,
额...有一个的坚实的基础.

56
00:02:30,597 --> 00:02:31,662
no pun intended there.
我不是在说笑.

57
00:02:33,032 --> 00:02:36,767
There's a holiday weekend this
weekend no Friday section and
这周末有公众假期, 所以这周五没课,

58
00:02:36,769 --> 00:02:39,603
no class on Monday until we
resume next Wednesday, and
下周一也没课,直到下周三重新开始上课,

59
00:02:39,605 --> 00:02:42,305
the primary thing I'm gonna do
next Wednesday,
下周三我的首要任务是

60
00:02:42,307 --> 00:02:44,341
not day after tomorrow but
不是后天的周三

61
00:02:44,342 --> 00:02:46,376
the next Wednesday, is talk a
little more about auto layout.
是下周周三, 是讲一些关于auto layout的内容.

62
00:02:46,378 --> 00:02:49,445
Cause you've only just seen
kind of a glimpse of auto
因为到目前为止你们只是瞥见了一点关于

63
00:02:49,447 --> 00:02:51,013
layouts so far and
auto layout的内容.

64
00:02:51,015 --> 00:02:53,849
I haven't even really told you
how to do auto layout and so
我实际上并没有告诉你们如何做auto layout

65
00:02:53,851 --> 00:02:55,383
you're kinda just fumbling
around and trying,
你们差不多只是在摸索和尝试

66
00:02:55,385 --> 00:02:58,619
trying to reproduce what I do
so next Wednesday we'll
重现我做过的内容. 所以下周三

67
00:02:58,621 --> 00:03:01,588
talk about how to really do
auto layout hm, and all that.
我们会讲如何做真正的auto layout和相关内容.

68
00:03:02,825 --> 00:03:05,225
'Kay, any questions before I
dive into this demo?
好的,在我开始演示之前还有没有问题?

69
00:03:06,194 --> 00:03:10,396
Hopefully my voice will hold
out I can already hear it
希望我的声音能坚持住, 我已经感觉到

70
00:03:10,398 --> 00:03:14,065
starting to not hold out but
we will see.
嗓子有些挺不住了, 但是...看吧.

71
00:03:14,067 --> 00:03:15,266
All right.
好的.

72
00:03:15,268 --> 00:03:21,839
So, I'm going to just go to
Xcode here, launch Xcode.
嗯,我现在点这里的Xcode, 运行Xcode.

73
00:03:22,941 --> 00:03:25,942
And we're gonna leave off
right where we, were,
我们将继续上次课程

74
00:03:25,944 --> 00:03:27,410
last time, in the calculator.
计算器程序的编写.

75
00:03:28,846 --> 00:03:32,681
There it is right here, and so
these are UI.
都在这里了, 这是UI.

76
00:03:32,683 --> 00:03:34,783
Hopefully you recognize that
and you did,
希望你们都认出来了并且

77
00:03:34,785 --> 00:03:36,051
did your homework.
做了作业.

78
00:03:36,053 --> 00:03:38,070
I hope.
我希望.

79
00:03:38,071 --> 00:03:40,088
And here is this area that I
selected at the end,
这是我在代码尾部选中的区域,

80
00:03:40,090 --> 00:03:43,290
which is this area that's
really has not,
这块区域并不是,

81
00:03:43,292 --> 00:03:47,928
this is not about how, how the
calculator gets presented on
并不是负责计算器如何在屏幕上呈现的.

82
00:03:47,930 --> 00:03:51,064
screen, this blue area is
about how the calculator is
这块蓝色的区域是关于这个计算器

83
00:03:51,066 --> 00:03:52,165
a calculator, okay?
为什么是个计算器, 可以么?

84
00:03:52,167 --> 00:03:54,367
This is where all our
calculations are and
这里是存放运算的地方

85
00:03:54,369 --> 00:03:57,302
this blue area really
shouldn't be in this class,
这个蓝色区域不应该出现在这个类里,

86
00:03:57,304 --> 00:04:00,839
this view controller class
because this is the C
这个视图控制器类. 因为这是我们MVC模型的

87
00:04:00,841 --> 00:04:01,973
of our MVC, okay.
控制器(Controller), 好么?

88
00:04:01,975 --> 00:04:06,910
And our MVC, this is the C,
this is the V, the view,
我们的MVC模型, 这是控制器(Controller), 这是视图(View),

89
00:04:06,912 --> 00:04:09,546
these are the minions that
this controller's using.
它们是控制器使用的小兵们.

90
00:04:09,548 --> 00:04:11,948
And today we're gonna create
the M.
今天我们将构建计算器的模型(Model).

91
00:04:11,950 --> 00:04:13,349
Okay?
The model.
好么?模型.

92
00:04:13,351 --> 00:04:15,351
The model is gonna be what our calcu,
这个模型将会决定我们的计,

93
00:04:15,353 --> 00:04:18,854
what our application is, which
is, it's a calculator.
我们的应用是什么, 也就是一个计算器.

94
00:04:18,856 --> 00:04:20,155
'Kay?
好么?

95
00:04:20,157 --> 00:04:23,758
We're also going to enhance
our calculator the primary new
我们将会加强这个计算器, 我们将赋予

96
00:04:23,760 --> 00:04:26,360
feature we're gonna give our
calculator is that
它的首要新特性是

97
00:04:26,362 --> 00:04:30,030
our calculators model is gonna
remember every operand and
我们的计算器模型将会记住所有我们要求的

98
00:04:30,032 --> 00:04:32,833
operation you ever asked it to do.
运算对象和运算.

99
00:04:32,835 --> 00:04:38,271
Okay, so right now as we do
operations we consume all
好的, 现在当我们做运算的是时候我们假设所有

100
00:04:38,273 --> 00:04:39,505
the operands.
运算对象.

101
00:04:32,835 --> 00:04:39,505
Okay, so right now as we do operations we consume all the operands.
好，现在我们注释掉我们刚才的操作。

103
00:04:39,507 --> 00:04:41,040
'Kay, they consume, kinda, they're gone.
他们没有了。

104
00:04:42,276 --> 00:04:43,792
So in this case,
所以在这种情况下，

105
00:04:43,793 --> 00:04:45,309
we're going to actually collect all the operations and
我们要收集所有在堆栈中的操作和

106
00:04:45,312 --> 00:04:48,346
operands in our, in a stack and then we can
运算，然后我们可以

107
00:04:48,348 --> 00:04:53,350
ask the model to, evaluate that stack of operations and
要求我们模型，求出我们所有操作运算的值，

108
00:04:53,352 --> 00:04:55,385
 operands at any time we want.
 在任何时候。

109
00:04:55,387 --> 00:04:57,654
And the reason we're adding that ability is because your homework,
我们增加这个功能的原因是因为你们的家庭作业，

110
00:04:57,656 --> 00:05:00,256
assignment number two, you're gonna add two
任务二，你需要添加两个

111
00:05:00,258 --> 00:05:03,726
major features where having all the operands and the
  主要功能，它包括所有的操作和运算

112
00:05:03,728 --> 00:05:06,628
operations in a stack is gonna be really valuable to you.
这将会对你很有用。

113
00:05:06,630 --> 00:05:09,264
So you'll be starting your second homework with what I
所以你要开始做第二份作业

114
00:05:09,266 --> 00:05:12,334
do today cause you'll need this capability to do what I
用我今天讲的东西，因为在里面你将会用到这些知识。

115
00:05:12,336 --> 00:05:13,735
         ask you there.

116
00:05:13,737 --> 00:05:14,902
Okay, and I'll talk about that at the end.
我会在结束的时候说一下这个问题。

117
00:05:14,904 --> 00:05:17,237
If I forget to talk about that, remind me.
如果我忘记说的话，提醒我一下。

118
00:05:17,239 --> 00:05:18,805
 Say, tell us about assignment two.
 就说和我们说一下那两个作业。

119
00:05:20,175 --> 00:05:21,240
Okay.

120
00:05:21,242 --> 00:05:22,908
So, how do we create a new class.
我们怎么去创建一个新的类。

121
00:05:22,910 --> 00:05:25,911
Because we're gonna put our model, 'kay, the calculator,
因为我们要把我们的模型，这个计算器，

122
00:05:25,913 --> 00:05:28,680
kind of, it, it's the guts, in a different class.
它是一个内脏（一部分），放在不同的类里。

123
00:05:28,682 --> 00:05:31,983
So how do we create a new class, in Xcode.
所以，我们应该怎么用Xcode创建一个新的类。

124
00:05:31,985 --> 00:05:33,651
We do that up here from the File menu.
我们从这里找到文件菜单

125
00:05:33,653 --> 00:05:35,619
We go, New > File.
然后选择 新建 -> 文件

126
00:05:35,621 --> 00:05:38,489
So, you're gonna do File menu > New > File for a lot of
所以你要使用 文件菜单 -> 新建 -> 文件

127
00:05:38,491 --> 00:05:41,291
different things you're gonna add to your project.
来为你的项目来添加各种不同的东西。

128
00:05:41,293 --> 00:05:43,693
Not even just, new classes or
不仅如此，新的类

129
00:05:43,695 --> 00:05:46,863
whatever, but, when you click that you're gonna see
或者随便什么，当你点击那里的时候你会看到

130
00:05:46,865 --> 00:05:48,497
there's a lot of different things you could add.
你可以添加很多不一样的东西

131
00:05:48,499 --> 00:05:49,865
And, we're in iOS, so
我们现在做的是 iOS，所以

132
00:05:49,867 --> 00:05:52,267
you're gonna click on this iOS thing at the top.
你需要点击上面的 iOS。

133
00:05:52,269 --> 00:05:53,635
And we wanna add a source file.
我们要添加一个资源文件。

134
00:05:53,637 --> 00:05:56,671
And over here we're gonna be doing this later in the quarter,
一会我们会在这里添加文件，

135
00:05:56,673 --> 00:06:04,378
this is how we basically add subclasses of iOS classes, Co, Cocoa Touch classes.
我们主要用这种方式来添加 iOS 的类和Cocoa Touch的类。

137
00:06:04,380 --> 00:06:06,446
But we're gonna do today this one Swift File,
但是今天我们这样来添加一个 Swift 的文件，

138
00:06:06,448 --> 00:06:08,948
you can see it's an empty Swift File.
你可以看到这是一个空的 Swift 文件。

139
00:06:08,950 --> 00:06:11,517
And since our model is completely UI independent it doesn't inherit,
因为我们的模型是一个独立的UI，它不需要继承，

140
00:06:11,519 --> 00:06:15,287
it doesn't subclass any IOS class or anything,
 它不是iOS或者其他的类的子类，

141
00:06:15,289 --> 00:06:17,923
it's just a basic, Swift File.
它只是一个基本的 Swift 文件。

142
00:06:17,925 --> 00:06:19,824
So I'm gonna pick on this Swift File,
所以我要选中这个 Swift 文件，

143
00:06:19,826 --> 00:06:23,394
click Next, and now it wants to know the name of
点击下一步，现在它需要知道文件名

144
00:06:23,396 --> 00:06:26,564
 it and where we wanna put it, and we're gonna put it in
 并且存放位置，我们想把它放在

145
00:06:26,566 --> 00:06:29,466
the same place that all our other swift files are.
和其他 Swift 文件相同的位置。

146
00:06:29,468 --> 00:06:30,901
Here's our Controller and
这里是我们的Contriller

147
00:06:30,902 --> 00:06:32,335
this AppDelegate, we moved it out of the way at the very
这个AppDelegate，在第一节课最开始的时候我们把它移出去了，

148
00:06:32,338 --> 00:06:34,571
beginning of the very first lecture but it's in there too.
但是它现在又在这里了。

149
00:06:34,573 --> 00:06:36,439
So we want to put it in this same directory.
所以我们想把它放在相同的路径下面。

150
00:06:36,441 --> 00:06:41,910
And we're gonna call this new class CalculatorBrain.
我们把这个新的类叫做CalculatorBrain。

151
00:06:41,912 --> 00:06:43,645
Now, you don't have to have the name of
在这里，你不用非得把这个 Swift 文件的名字

152
00:06:43,647 --> 00:06:47,048
this Swift File here be the name of the primary class but
写成一个主类的名字

153
00:06:47,050 --> 00:06:48,049
we always do that.
但是我们一般都这么写。

154
00:06:48,051 --> 00:06:49,617
It would be kinda confusing to
它会让人有点困惑

155
00:06:49,619 --> 00:06:52,019
people a little bit if the name of the Swift File
如果Swift的文件名

156
00:06:52,021 --> 00:06:54,554
was different than whatever the primary class is in there.
不同于这里面的任何的主类。

157
00:06:54,556 --> 00:06:55,755
But it's certainly legal.
但是它是合法的。

158
00:06:55,757 --> 00:06:56,422
All right.

159
00:06:56,424 --> 00:06:58,857
And Swift, the name of the file really doesn't mean anything.
Swift的文件名并不代表一切。

161
00:06:58,859 --> 00:07:00,359
It's what's inside that matters.
它里面有什么才是主要的。

162
00:07:00,361 --> 00:07:04,929
But, CalculatorBrain is gonna be the name of our class, our model.
但是，CalculatorBrain将会是我们类和模型的名字，

164
00:07:04,930 --> 00:07:06,396
I'm calling it that cause it's the brain of our calculator,
我这么叫它是因为它是我们计算器的大脑，

165
00:07:06,399 --> 00:07:07,898
I'm trying to pick a descriptive name.
我尝试去取一个描述性的名字。

166
00:07:09,201 --> 00:07:12,302
Notice the capitalization here,
注意这里的大写，

167
00:07:12,304 --> 00:07:16,306
types in swift, we always capitalize them.
Swift 里面的类型，我们一般都大写。

168
00:07:16,308 --> 00:07:19,409
And we do not put underbars and other stuff in there.
我们不要把下划线之类的放在这里。

169
00:07:19,411 --> 00:07:20,609
Okay? We use what's called this
在这里我们使用一个叫做

170
00:07:20,611 --> 00:07:25,380
camel notation here, where every word gets capitalized,
驼峰的命名法，每一个单词都要有大写，

171
00:07:25,382 --> 00:07:27,882
including the first name, word for types.
包括名字和类型。

172
00:07:27,884 --> 00:07:31,219
Everything else, we don't capitalize.
其他的东西，我们都不用大写。

173
00:07:31,221 --> 00:07:34,755
So property names and things like that, function names,
所有属性的名字和其他其他一些类似的，函数名，

174
00:07:34,757 --> 00:07:36,457
those all start with lower case,
这些都要开头用小写，

175
00:07:36,459 --> 00:07:38,992
they still do the uppercase and the other words.
但是他们后面的单词的首字母要用大写。

176
00:07:38,994 --> 00:07:40,427
That way we, in our reading our code we
用这种方法，我们读代码的时候

177
00:07:40,429 --> 00:07:43,196
can really quickly pick out what to type and what to not.
我们可以很快的找到什么类型和不是的。

178
00:07:43,198 --> 00:07:45,164
'Kay? So please adhere to that.
所有请坚持这么写。

179
00:07:45,166 --> 00:07:48,334
If you don't, you're gonna look like a newb out there.
如果你不这么做的话，那你看起来就像一个新手了。

180
00:07:48,336 --> 00:07:49,501
'Kay. Calculator brains what we're
那个我们叫它计算器大脑的，

181
00:07:49,503 --> 00:07:50,835
gonna call it, I'm gonna create it.
下面我要开始创建它。

182
00:07:51,938 --> 00:07:53,121
Here it is right here.
这里

183
00:07:53,122 --> 00:07:54,305
I'm gonna make it my whole screen.
我把它设置为全屏。

184
00:07:55,541 --> 00:07:58,975
You can see that the import here is not import UI kit,
你可以看到这里有一个import，但是没有导入UI kit，

185
00:07:58,977 --> 00:08:00,477
it's import Foundation.
他导入了Foundation。

186
00:08:00,479 --> 00:08:03,379
Foundation is that layer, that kinda core services layer I
Foundation是一个核心的服务层，

187
00:08:03,381 --> 00:08:05,581
talked about in the first lecture.
在第一节课里我已经讲了。

188
00:08:05,583 --> 00:08:07,883
It don't have many UI stuff in it which is good because our
它没有太多UI的东西，这是很好的，因为

189
00:08:07,885 --> 00:08:11,687
model is UI independent so there should be no UI in here.
我们的模型是独立UI的，所以这里应该没有UI的东西。

190
00:08:11,689 --> 00:08:15,957
So we would never be importing UI kit into a model class,
所以我们永远不要再模型类里导入UI组件。

191
00:08:15,959 --> 00:08:17,392
             'kay?

192
00:08:17,393 --> 00:08:18,826
 You can feel free to stop me, by the way,
你可以随时让我停下来，

193
00:08:18,828 --> 00:08:19,793
if you have any questions.
如果你又任何的问题。

194
00:08:19,795 --> 00:08:22,095
All right, so we're gonna create a new class,
所以我们要创建一个新类，

195
00:08:22,097 --> 00:08:23,029
you already know how to do that.
你已经知道该怎么去做了。

196
00:08:23,031 --> 00:08:24,364
We just type class and
我们创建这个类

197
00:08:24,366 --> 00:08:27,500
then the name of the class, it's gonna be CalculatorBrain.
然后给这个类取一个名字，我们就叫它CalculatorBrain。

198
00:08:27,502 --> 00:08:32,537
Now, this class is not going to inherit from any other class,
现在，这个类不会继承其他的类。

200
00:08:32,539 --> 00:08:35,640
Just gonna be a basic swift, class.
只是一个基本的 Swift 类。

201
00:08:35,642 --> 00:08:38,509
 Now sometimes your model might
  inherit from a class called
有时候你的模型会继承一个叫做 NSObject

202
00:08:38,511 --> 00:08:40,861
         NSObject, and
的类，

203
00:08:40,862 --> 00:08:43,212
 I'll talk about that a little
 later maybe on Wednesday even.
这个我后面会讲解，可能这周三讲。

204
00:08:43,215 --> 00:08:46,683
 You'll get a little bit if you
   inherit from NSObject, but
如果继承 NSObject，你将会得到一些（函数）。

205
00:08:46,685 --> 00:08:50,587
  we're just gonna have it be
 basic swift base class, 'kay.
但是这里我们就用 swift 基类。

206
00:08:50,589 --> 00:08:52,388
  It doesn't, doesn't need to
   inherit any functionality.
它不需要继承任何功能函数。

207
00:08:53,691 --> 00:08:55,224
             Okay.

208
00:08:55,225 --> 00:08:56,758
  So what's gonna be our data
          structure of
所以，我们的 calculator brain 的

209
00:08:56,761 --> 00:08:57,859
     our calculator brain.
数据结构是什么样的呢？

210
00:08:57,861 --> 00:08:59,961
   It, it has to be a little
    different than the data
它必须有点不同于我们的

211
00:08:59,963 --> 00:09:01,662
    structure we used in our
         controller to
controller 中用于捕获操作数的数据结构，

212
00:09:01,664 --> 00:09:04,565
 capture the operand because we
     gotta capture operand,
因为我们得捕获操作数，操作。

213
00:09:04,567 --> 00:09:07,368
  operations and operands both
           into this.
以及两者的运算。

214
00:09:07,370 --> 00:09:12,305
  So we want it to be a stack,
 I'm gonna call it opStack and
所以，我们需要一个栈，我称之为 opStack

215
00:09:12,307 --> 00:09:14,741
 but the type can't be array of
            double.
但是这个类型不能是 double 数组。

216
00:09:15,743 --> 00:09:20,245
   Okay, because operands are
     doubles but operations
因为操作数是 doubles， 但运算则像

217
00:09:20,247 --> 00:09:23,648
  are like a combination of a
   syn, a mathematical symbol
一种语法的结合， 一个数学符号。

218
00:09:23,650 --> 00:09:26,651
 like plus, times and then also
          a function.
比如相加，相乘，当然也包括函数。

219
00:09:26,653 --> 00:09:29,186
  Function that actually does
        the thing, 'kay?
函数实际上也是一样的东西。

220
00:09:29,188 --> 00:09:30,888
 So obviously we can't do that
               so
所以显然，我们不能这么做。

221
00:09:30,890 --> 00:09:32,022
 we're gonna have to need some,
我们需要一些

222
00:09:32,024 --> 00:09:34,691
  some new data structure I'm
      gonna call that data
新的数据结构，我叫这种数据结构

223
00:09:34,693 --> 00:09:37,760
  structure op and we're gonna
    define that in a second.
为 op， 我们随后就定义这个结构。

224
00:09:37,762 --> 00:09:41,663
  So op is gonna be something
  that could be an operand or
所以 op 可能是操作数，也可能是

225
00:09:41,665 --> 00:09:43,532
      maybe it could be an
           operation.
运算。

226
00:09:43,534 --> 00:09:45,233
             'Kay?
     It could be either or.
它可能是两者中的任一种。

227
00:09:45,235 --> 00:09:47,519
             'Kay?

228
00:09:47,520 --> 00:09:49,804
  Now a couple of things about
    this here is of course I
现在有几件事情，当然，

229
00:09:49,806 --> 00:09:51,572
 have to initialize this so I'm
            gonna do
我需要初始化，

230
00:09:51,574 --> 00:09:54,575
  the exact same thing that I
 did in the controller which is
我将做在 controller 中同样的事情，

231
00:09:54,577 --> 00:09:56,810
 I'm just gonna create an empty
          array of op.
那就是我要创建一个新的 op 数组。

232
00:09:56,812 --> 00:09:59,496
             'Kay?
              And

233
00:09:59,497 --> 00:10:02,181
  I'm even gonna use a little
    different syntax, 'kay?
我甚至要用一点不一样的语法，

234
00:10:02,183 --> 00:10:03,382
     We've been using this.
我们使用这个。

235
00:10:03,384 --> 00:10:05,851
   I like this syntax because
         especially for
我喜欢这个语法，特别是对于

236
00:10:05,853 --> 00:10:08,553
  people who are first time to
     swift it's very clear,
那些初次接触 swift 的，它非常清晰。

237
00:10:08,555 --> 00:10:12,624
  this is an array and inside
  the array are these ops but
这是一个数组， 在数组中，是这些 op，

238
00:10:12,626 --> 00:10:17,661
   this is evidently not the
   syntax that is preferred.
但这并不是推荐的语法。

239
00:10:17,663 --> 00:10:23,433
    The preferred syntax is
   actually to do [Op] 'kay?
推荐的语法实际上是使用 [Op]。

240
00:10:23,435 --> 00:10:27,070
  So this is just an alternate
     syntax, putting square
这是另一种可选择的语法，把类型放在

241
00:10:27,072 --> 00:10:29,739
 brackets with the type in the
 middle for declaring an array.
方括号中，这样就声明了一个数组。

242
00:10:29,741 --> 00:10:32,008
  It's exactly the same thing
     just different way of
这是一样的东西，只是不一样的方式。

243
00:10:32,010 --> 00:10:34,276
 typing in, identical in every
         possible way,
写法不一样，但其他都一样。

244
00:10:34,278 --> 00:10:35,777
     it's exactly the same.
真的是相同的东西。

245
00:10:35,779 --> 00:10:37,062
             Okay.

246
00:10:37,063 --> 00:10:38,346
  I think this is a little bit
      preferred because if
我认为这是更好的方式。因为

247
00:10:38,348 --> 00:10:41,449
  you ever initialize an array
     which will see later.
如果你曾初始化过数组，你就明白。

248
00:10:41,451 --> 00:10:43,884
 You use this syntax to create
         the array and
你使用这种语法创建数组，

249
00:10:43,886 --> 00:10:45,686
       put things in it.
并将东西放在其中。

250
00:10:45,687 --> 00:10:47,487
   So I, I can understand why
         they do that.
所以我理解他们这样做的原因。

251
00:10:47,490 --> 00:10:50,257
             Okay?
   So this is an array of op.
这是一个 op 数组。

252
00:10:50,259 --> 00:10:50,924
        That make sense?
这有意义的。

253
00:10:51,860 --> 00:10:53,859
   Now, let's talk about op.
现在，让我们说说 op。

254
00:10:53,861 --> 00:10:55,094
 What kinda thing should op be?
op 会做哪些事情？

255
00:10:55,096 --> 00:10:57,596
    Well, we could make op a
             class.
好吧，我们可以将 op 变成一个类。

256
00:10:57,598 --> 00:10:59,731
  An op could have a property
            for op,
然后 op 应当有属性：操作，

257
00:10:59,733 --> 00:11:02,033
 for an operand, which would be
   the value of the operand.
操作数，也就是操作数的值。

258
00:11:02,035 --> 00:11:05,169
     It could have another
    property, which is the,
他还应该有另一个属性，那就是，

259
00:11:05,171 --> 00:11:07,371
  symbol, mathematical symbol
     for the operation and
符号，用于运算的数学符号。

260
00:11:07,373 --> 00:11:10,173
 another property, which was a
    function, which does it,
还有属性，函数，这个，

261
00:11:10,175 --> 00:11:12,509
 and obviously, if the operand
            is set,
很明显，如果一个操作数被赋值了，

262
00:11:12,511 --> 00:11:15,144
  then the other two would be
    not set and vice versa.
那另两个还没被赋值。反过来，也一样。

263
00:11:15,146 --> 00:11:18,481
 But that, that's a little bit
   weird to have a class that
但这样就有些奇怪。一个类拥有一些

264
00:11:18,483 --> 00:11:21,250
 has properties that sometimes
        they're set and,
属性，有时他们被赋值了，

265
00:11:21,252 --> 00:11:23,218
  and if other things are set,
        they're not set.
但其他东西被赋值了，但他们却没被赋值。

266
00:11:23,220 --> 00:11:24,285
 It's really not what we want.
这不是我们想要的。

267
00:11:24,287 --> 00:11:27,621
   What we really want is an
             enum.
我们需要的是枚举类型。

268
00:11:28,591 --> 00:11:31,658
 Okay, so you're probably used
 to enums in other languages so
你可能在其他编程语言中使用过枚举，

269
00:11:31,660 --> 00:11:32,959
    I'm gonna create an ema,
所以我将创建一个枚举。

270
00:11:32,961 --> 00:11:35,728
 [UNKNOWN] enum, it looks very
   similar creating a class.
枚举，类似创建一个类。

271
00:11:35,730 --> 00:11:38,397
    I just use the word enum
       instead of class,
我使用 enum，而不是 class。

272
00:11:38,399 --> 00:11:41,633
  obviously no inheritance for
          enum, sorry.
显然，枚举没有继承特性。

273
00:11:41,635 --> 00:11:45,537
 But enums can have functions,
      just like the class,
但枚举和类一样，有函数。

274
00:11:45,539 --> 00:11:49,474
 they can also have properties
 but only computed properties.
他们也有属性，但只是计算类属性。

275
00:11:49,476 --> 00:11:51,242
    'Kay, the Camry's stored
          properties.
Camry 存储属性。

276
00:11:52,278 --> 00:11:55,779
  So you know enums are kinda
      for basic types and
你们知道枚举是基本类型，

277
00:11:55,781 --> 00:11:58,782
  enums are really great when
 you have something that can be
枚举非常棒，特别是你有一些东西，在某个

278
00:11:58,784 --> 00:12:01,317
    one thing one time and a
 different thing another time.
时间有一个值，在另外一些时候有另外的值。

279
00:12:01,319 --> 00:12:02,585
   And never both at the same
             time,
但不会同时拥有两个值。

280
00:12:02,587 --> 00:12:03,952
  that's kinda what enums are
             right,
这样，使用枚举是对的。

281
00:12:03,954 --> 00:12:06,421
 they're enumerating different
        possibilities so
它们枚举不同的可能性，所以

282
00:12:06,423 --> 00:12:09,257
   we could say you know case
   operand and we could have
我们能说，你知道 case 表达式，

283
00:12:09,259 --> 00:12:15,563
 a case operation, to have the
 different things that we have.
我们可以使用 case 语句，去表达我们拥有的不同东西。

284
00:12:15,565 --> 00:12:19,133
 Now, in other languages, this
 would be as far as we can go.
在其他编程语言中，这将难以实现。

285
00:12:19,135 --> 00:12:21,101
    And this would be pretty
            useless.
然后这也是相当没用的。

286
00:12:21,103 --> 00:12:24,270
   Because if we had an array
   that just said whether it
因为我们有一个数组，他可能是一个

287
00:12:24,272 --> 00:12:26,105
      was an operand or an
 operation, that doesn't help.
操作数，或者运算，这没有任何帮助。

288
00:12:26,107 --> 00:12:27,973
   I need the actual operand.
我需要一个实际的操作数。

289
00:12:27,975 --> 00:12:30,242
     I need the operations
    mathematical symbol and
我需要操作数学符号，还有

290
00:12:30,244 --> 00:12:31,977
         its function.
它的函数。

291
00:12:31,978 --> 00:12:33,711
  I need them, they have to be
        in this e-mail.
我需要它们，它们要在这个电子邮件中。

292
00:12:33,714 --> 00:12:36,448
  And Swift has a really cool
     feature where you can
Swift 有一个非常酷的特点，你们可以

293
00:12:36,450 --> 00:12:41,085
 associate data with any of the
      cases in the e-mail.
将数据和任何 case 中的电子邮件关联起来。

294
00:12:41,087 --> 00:12:44,021
  So for an operand I'm gonna
   associate the data double.
所以对于一个操作数，我们将关联 double 数据类型。

295
00:12:45,123 --> 00:12:48,157
  So if my enum is an operand
        it'll have this
所以我的枚举是一个操作数，它有这个

296
00:12:48,159 --> 00:12:49,558
   double associated with it,
double 和它关联。

297
00:12:49,560 --> 00:12:52,194
  that's gonna be the value of
          the operand.
这将是这个操作数的值。

298
00:12:52,196 --> 00:12:54,013
       And similarly for
类似地，

299
00:12:54,014 --> 00:12:55,831
  operation I'm actually gonna
   do unary operation first,
对于运算，我实际上首先使用一元操作。

300
00:12:55,833 --> 00:12:57,866
    that's a single argument
           operation.
这是单个参数的运算。

301
00:12:57,868 --> 00:13:00,768
 I'm gonna have a string which
    is gonna be the symbol,
首先我需要用一个字符串来表示符号，

302
00:13:00,770 --> 00:13:01,936
  the mathematical symbol for
数学运算符
303
00:13:01,938 --> 00:13:04,238
   it and of course I'm gonna
        have a function.
我当然还需要一个函数来做这个运算。

304
00:13:05,341 --> 00:13:08,408
 Okay again functions are just
        types in swift,
再重提一遍，函数在swift里也是一种类型，

305
00:13:08,410 --> 00:13:11,344
 it's no different than string
 'kay we're just saying this is
与字符串相比并没有任何的不同，我们只需要知道

306
00:13:11,346 --> 00:13:13,612
 a function, put a function in
             there.
这是个函数，放在这就好了。
307
00:13:13,614 --> 00:13:15,147
  A lot of times we'll do the
        curly braces and
很多时候在这里我们会通过用花括号

308
00:13:15,149 --> 00:13:17,883
 put a closure use closures to
    create our function but
写一个闭包来实现这个函数，
309
00:13:17,885 --> 00:13:19,584
     we could create actual
         functions and
但是我们也可以通过在其他地方写一个真正的函数

310
00:13:19,586 --> 00:13:21,185
   pass them in there, that's
             fine.
然后传递进来，也是没有问题的。

311
00:13:21,187 --> 00:13:25,289
    So, and we'd also want a
   binary function here that takes two arguments.
继续，我们还需要一个有2个参数的二元运算函数，



313
00:13:26,959 --> 00:13:28,625
      Binary operation and
二元运算，然后

314
00:13:28,627 --> 00:13:34,296
 just those two arguments here
       in it's function. Okay?
在里面加一个带2个参数的函数。


316
00:13:34,297 --> 00:13:37,499
   So now we have the stack. Okay. Which is an array of Ops.
我们这里还有一个栈，是由Op组成的数组。

318
00:13:37,501 --> 00:13:41,369
 And these ops are either each
 op in this, is array is either
这个数组的元素要么是一个操作数，

319
00:13:41,371 --> 00:13:44,638
   an operand or it's one of
 these two kinds of operations.
要么是刚才这个枚举里两种运算中的一种。

320
00:13:46,308 --> 00:13:49,142
   Okay so so this is great.
很好

321
00:13:49,144 --> 00:13:53,979
 We got this op it's either an
    operation or an operand.
我们现在有了Op，它是操作数或者是运算。

322
00:13:53,981 --> 00:13:59,251
 How are we going to, you know,
        put things into this op stack for example and something like that.
下边我们要做的是往opStack这个数组里放东西。


324
00:13:59,253 --> 00:14:01,653
  So let, let's go talk about,
            the API.
这里简单说一下API。

325
00:14:01,655 --> 00:14:05,356
 A, API stands for application
     programing interface.
API指的是应用程序接口。

326
00:14:05,358 --> 00:14:09,060
  API is kind of the methods, all
   the methods and properties
API就是组成你的类里边所有属性


327
00:14:09,062 --> 00:14:13,230
  that make up your class, the
      description of them.
和方法的描述。

328
00:14:13,232 --> 00:14:16,066
  So I'll use that word a lot,
              API.
我之后会经常提到这个词。

329
00:14:16,068 --> 00:14:18,835
 And we really need to be able
 to put an operand on there and
现在我们需要想办法往opStack这个栈里压入

330
00:14:18,837 --> 00:14:20,736
 stack, and we need to be able
    to put an operation on.
操作符和运算。

331
00:14:20,738 --> 00:14:24,573
  So I'm gonna have a function
    called pushOperand, and
所以我写一个叫pushOperand的函数，

332
00:14:24,575 --> 00:14:27,809
  it's gonna take an operand,
       which is a double.
需要传入一个double类型的参数作为操作数。

333
00:14:27,811 --> 00:14:30,578
   Okay it's not gonna return
      anything yet anyway.
不需要返回值。

334
00:14:30,580 --> 00:14:33,715
  And to push an operand on my
  stack, could not be easier,
要把一个操作数压进栈非常简单，

335
00:14:33,717 --> 00:14:36,217
       I'm just gonna say
        opStack.append,
 我只需要写opStack.append,

336
00:14:36,219 --> 00:14:42,355
 you'll remember that append is
    a function in array and the thing that you put on,
要记住append是数组从尾部添加元素的函数，


338
00:14:42,357 --> 00:14:45,858
    obviously has to be this
         little type T.
这有一个类型T，

339
00:14:45,860 --> 00:14:48,627
 T is whatever you put in here,
      so op in this case.
T代表你添加到数组里的类型，在这里是Op。

340
00:14:48,629 --> 00:14:50,729
 So we have to have an op here.
我们要加一个Op进去。

341
00:14:50,731 --> 00:14:52,964
   How do you create an enum
             item?
我们怎么新建一个枚举项呢？

342
00:14:52,966 --> 00:15:01,539
  You just Op.Operand and you
 give it the associated value. Okay？
只需要写Op.Operand然后给它一个相关值。

344
00:15:01,541 --> 00:15:10,013
 So, very simple kind of way to
     create these enums and associate the value with them.
看，新建枚举项以及他们的相关值非常简单。


346
00:15:10,015 --> 00:15:11,114
   Any questions about that?
这里有问题吗？

347
00:15:12,450 --> 00:15:13,749
    Okay, and then how about
          operations?
���好，那运算呢？

348
00:15:13,751 --> 00:15:15,384
  We'll have instead of push,
我们这次不写push，

349
00:15:15,386 --> 00:15:18,720
     we're gonna call this
       performOperation.
而是写一个叫performOperation （执行运算）的函数。

350
00:15:18,722 --> 00:15:20,922
     And I think when I do
   performOperation, what I'm
并且我希望当我执行performOperation的时候，

351
00:15:20,924 --> 00:15:23,024
  gonna have is, my CalculatorBrain is going to have
我的CalculatorBrain类已经有一些

352
00:15:23,026 --> 00:15:26,493
  a bunch of known operations,
   things it knows how to do.
已知的运算以及他们具体的运算方法。

353
00:15:26,495 --> 00:15:27,861
    And when you perform an
           operation,
然后当你执行一个运算的时候，

354
00:15:27,863 --> 00:15:30,697
      you just specify the
   mathematical symbol of it.
你只需要写出它的数学符号就可以了。

355
00:15:30,699 --> 00:15:36,301
 So the argument here is going
         to be symbol, which is a string.Okay?
所以这个函数的参数是一个数学符号，也就是字符串。

358
00:15:36,303 --> 00:15:41,306
  So, to append an op on here
     that is, an operation,
我们要把运算，也就是一个Op压进栈，

359
00:15:41,308 --> 00:15:43,274
  I'm gonna need to have these
       known operations.
我需要用到已知的运算。

360
00:15:43,276 --> 00:15:44,775
  So, how am I gonna do that?
要怎么做呢？

361
00:15:44,777 --> 00:15:47,878
      Well, to have known
  operations, I'm gonna create
我们要新建另外一个实例变量knownOps作为

362
00:15:47,880 --> 00:15:51,048
 another instance variable here
      called knownOps, so
 存储已知运算的地方。

363
00:15:51,050 --> 00:15:55,251
      my known operations. And it's gonna be a
          dictionary.
这些已知的运算，是一个字典类型。

365
00:15:55,253 --> 00:15:58,987
   Okay, now, you read about
        dictionaries in  last week's reading assignment.
上周的阅读材料里你们应该已经读到过字典类型了。



367
00:15:58,989 --> 00:16:00,489
 That's why I have the reading
     assignment due today.
 这就是为什么今天是阅读材料的截止日期，

368
00:16:00,491 --> 00:16:02,257
   Cuz then I can know you've
        read about them.
这样我就能知道你们已经读过了。

369
00:16:02,259 --> 00:16:02,824
        I hope you have.
希望你们确实读了。

370
00:16:05,495 --> 00:16:07,428
   And so, how do I create a
          dictionary?
我们如何新建一个字典？

371
00:16:07,430 --> 00:16:08,995
      It looks like this,
          Dictionary.
像这样。

372
00:16:08,997 --> 00:16:11,531
   And it's the same kind of
    thing with these angled
同样是使用尖括号，

373
00:16:11,533 --> 00:16:14,434
 brackets, because you have to
    say for the dictionary,
你必须为字典

374
00:16:14,436 --> 00:16:17,036
  what type are the keys, what
      type are the values.
建立相对应的键值关系。

375
00:16:17,038 --> 00:16:20,506
  And our dictionary is gonna
 have keys that are strings and
在这里，键是字符串

376
00:16:20,508 --> 00:16:22,874
  it's gonna have values that
            are ops.
值的类型是Op。

377
00:16:22,876 --> 00:16:26,478
       Oops, sorry, ops.
哦，对不起，Op

378
00:16:26,480 --> 00:16:29,947
   Okay, and I'm gonna create
              one. Okay?
好，新建了一个字典。

380
00:16:29,949 --> 00:16:32,316
   Everyone understand this?
大家都明白这个了吗？

381
00:16:32,317 --> 00:16:34,684
  Now, this knownOps, I'm just
 gonna put all of the ops that
现在在这个knownOps变量里，我要把所有

382
00:16:34,687 --> 00:16:38,955
 I know in there, where the key
 is the symbol and the value is
我知道的运算放进去，键是运算符号

383
00:16:38,957 --> 00:16:42,392
  the actual op, and then when
 someone says performOperation,
值是实际的Op也就是运算方法，每次我要执行performOperation时，

384
00:16:42,394 --> 00:16:44,527
  I'm gonna look it up in the
           knownOps.
我会去knownOps里去找那些已知的运算。

385
00:16:44,529 --> 00:16:47,329
    And when I find it, then
    that's the operation I'm
当我找到的时候，我就要把这个

386
00:16:47,331 --> 00:16:49,531
 gonna push onto the stack, all
             right?
运算压到opStack这个栈里。

387
00:16:49,533 --> 00:16:51,183
          Make sense?
能明白吗？
388
00:16:51,184 --> 00:16:52,834
    But I have to load this
          knownOps up.
但是我需要预先载入knownOps。
389
00:16:52,836 --> 00:16:55,903
  Oh, but first of all, so let
   me talk about this syntax.
哦，首先，我要说一下这个语法。

390
00:16:55,905 --> 00:17:00,941
 Just like array has a special
     syntax with the square brackets, so does dictionary.
跟前边数组使用方括号的特殊语法一样，字典也可以这么写。

392
00:17:00,943 --> 00:17:03,510
  So to have a dictionary like
     this with this kind of
如果字典用这种写法，

393
00:17:03,512 --> 00:17:07,080
 special syntax, we're gonna do
      open square bracket.
我们需要用方括号，

394
00:17:07,082 --> 00:17:12,752
  And then a colon in between
          the key and
然后中间用冒号隔开键和值，

395
00:17:12,754 --> 00:17:15,254
  the value type, so it looks
           like that.
就像这样。

396
00:17:15,256 --> 00:17:17,789
  So it looks very similar to
           array, but
跟数组很像，但是

397
00:17:17,791 --> 00:17:22,660
  you've got this thing where
     you've got the key and the value separated by a
     colon. Okay？
你需要用冒号把键和值分隔开。

400
00:17:23,796 --> 00:17:25,429
 Same thing, though, exact same
             thing.
其实是完全一样的。

401
00:17:25,431 --> 00:17:27,430
Just a dictionary, strings,
仅仅是字典，字符串，

402
00:17:27,432 --> 00:17:28,698
looking up in strings to find
              ops.
用字符串找 op

403
00:17:28,700 --> 00:17:32,701
All right, so how am I gonna
   initialize this knownOps?
好，那我们怎么初始化这个已知的 op

404
00:17:32,703 --> 00:17:33,869
 Well, this is a great time for
这是我们

405
00:17:33,871 --> 00:17:37,906
the first time for you see an
       initializer, okay?
第一次提到 initializer

406
00:17:37,908 --> 00:17:41,876
So far we've been creating
 classes like right here, okay,
到此，我们已经通过加括号创建了一个像这样类

407
00:17:41,878 --> 00:17:44,311
just by putting these
          parentheses.

408
00:17:44,313 --> 00:17:46,680
And I told you that was
   calling an initializer in
这就是在调用字典的 initializer

409
00:17:46,682 --> 00:17:47,947
Dictionary, okay, and

410
00:17:47,949 --> 00:17:50,817
this one was calling an
     initializer in Array.
这是在调用数组的 initializer

411
00:17:50,819 --> 00:17:52,585
And so we're gonna have our
       own initializer in
然而，我们会为 CalculatorBrain 设置自己的 initializer

412
00:17:52,587 --> 00:17:55,421
CalculatorBrain, and

413
00:17:55,422 --> 00:17:58,256
we just do that by saying
     init, like this, okay.
通过像 init 这样的形式

414
00:17:58,258 --> 00:18:01,726
Now any time someone says
 something like let brain equal
现在不论何时 使用 let brain = CalculatorBrain()

415
00:18:01,728 --> 00:18:05,296
CalculatorBrain, with the
parentheses, okay?

416
00:18:05,298 --> 00:18:07,531
It's going to call an init
              that
就会调用匹配对应参数的 init 方法

417
00:18:07,533 --> 00:18:09,667
matches the same arguments.

418
00:18:09,669 --> 00:18:11,668
In this case, no arguments, so
   it's gonna call this init.
在这里，没有参数，所以将会调用这个 init 方法

419
00:18:13,505 --> 00:18:14,070
Okay.

420
00:18:15,439 --> 00:18:16,838
Couldn't be simpler there.
就是这么简单

421
00:18:16,840 --> 00:18:18,173
So what are we gonna do in
           this init?
那我们要在这个初始化方法里做什么呢？

422
00:18:18,175 --> 00:18:20,375
We're just gonna initialize
       this known op, so
我们将要初始化 op

423
00:18:20,377 --> 00:18:24,545
I'm just gonna start putting
    some known ops into this
于是，加入一些已知的 op 到 op 的字典里

424
00:18:24,547 --> 00:18:26,780
knownOps dictionary.

425
00:18:26,782 --> 00:18:31,617
We need our friend special
   characters here for that.
我们需要刚才用过的特殊字符

426
00:18:31,619 --> 00:18:34,253
So let's go ahead and
让我们继续

427
00:18:34,254 --> 00:18:36,888
put, well, let's put times
      here first, I guess.
先加入乘法

428
00:18:36,891 --> 00:18:39,257
Okay, and we need to create an
           operation.
再创建一个操作

429
00:18:39,259 --> 00:18:40,392
How do we create an operation?
怎么创建一个操作呢？

430
00:18:40,394 --> 00:18:43,461
Very similar to how we created
           this enum.
跟我们创建这个枚举很像。

431
00:18:43,463 --> 00:18:47,431
Op, dot, and times is a binary
           operation.
op， 点，乘法时一个二元运算符

432
00:18:47,433 --> 00:18:49,566
And you can see that it's
      typing this for me.
自动为我补全了。

433
00:18:49,568 --> 00:18:51,735
I'm just pressing Tab to get
             along.
按 Tab 继续

434
00:18:51,737 --> 00:18:56,105
This is the symbol, which is
        this thing here.
这是这里的符号

435
00:18:56,107 --> 00:18:58,908
Now, this is kinda bad code
        that I ended up
现在，我完成一个糟糕的代码

436
00:18:58,910 --> 00:19:00,809
typing this twice in the same
             line.
同一行输入了这段两次

437
00:19:00,811 --> 00:19:03,378
If I accidentally use the
            wrong x,
假如不小心输错 x

438
00:19:03,380 --> 00:19:06,881
like some x from somewhere
   else or the x just from my
比如 x 来自别的地方或者

439
00:19:06,883 --> 00:19:10,451
keyboard might be different
from this x, than this x, ugh,
我键盘的 x 不同于这个 x

440
00:19:10,453 --> 00:19:12,920
we could get in trouble where
  these things don't match up.
万一它们不匹配，我们就会遇到问题

441
00:19:12,922 --> 00:19:15,489
So later, in the, right at the
     very end of the demo,
晚点在演示快结束的时候，

442
00:19:15,491 --> 00:19:16,857
I'm gonna show you how we
        could do this in
我会向你展示不需要像这样输入两次 x 的方法

443
00:19:16,859 --> 00:19:20,960
a way where we don't have to
  type this x twice like that.

444
00:19:20,962 --> 00:19:22,161
Okay.

445
00:19:22,162 --> 00:19:23,361
But now we just need the
           function.
但是现在我们只需要这个方法

446
00:19:23,364 --> 00:19:25,230
We know how to do that with
           closures.
我们知道如何用闭包实现

447
00:19:25,232 --> 00:19:27,866
We say $0 times $1.
用 $0 * $1

448
00:19:27,868 --> 00:19:29,000
End the closure.
结束闭包

449
00:19:29,002 --> 00:19:31,736
And yes, I could put this
        closure outside,
当然，这是最后，于是我也可以把闭包放到外面

450
00:19:31,738 --> 00:19:33,838
since it's the last thing
             here.
因为这个闭包在代码结尾处

451
00:19:33,840 --> 00:19:37,107
That is also legal to do when
        you're creating
当你创建这样的操作时，也是合法的

452
00:19:37,109 --> 00:19:39,109
the operations like this.

453
00:19:39,111 --> 00:19:40,310
'Kay?

454
00:19:40,312 --> 00:19:41,377
So that's kinda nice.
这看上去很棒吧。

455
00:19:41,379 --> 00:19:44,880
Let's do our other three
    binary operations here.
让我们来加入另外三种二元操作

456
00:19:44,882 --> 00:19:46,982
We'll go divide.
除法

457
00:19:46,984 --> 00:19:49,784
And this is where it really
    gets annoying to have to
这就是非得输入两遍的烦人的地方

458
00:19:49,786 --> 00:19:51,736
type it twice.

459
00:19:51,737 --> 00:19:53,687
But I have to show you
  something else before I can
但我要在演示如何做之前给你看点其它东西。

460
00:19:53,690 --> 00:19:56,357
show you how to do that right.

461
00:19:57,726 --> 00:19:58,591
Let's go here.
从这里开始

462
00:19:58,593 --> 00:20:02,362
And there we have minus.
这里我们有减法

463
00:20:02,364 --> 00:20:04,997
You can see there's two
  different minuses there, so
你可以看到有两种减法

464
00:20:04,999 --> 00:20:07,866
hopefully I clicked the same
   minus in both those spots.
我在这两处都点了同一个减法符号

465
00:20:07,868 --> 00:20:09,434
And then we change these
            things.
改一下这里

466
00:20:09,436 --> 00:20:13,671
We know that divide is 1
       divided by $0, and
除法是用 $1 除以 $0

467
00:20:13,673 --> 00:20:15,106
this is plus.
加法

468
00:20:16,742 --> 00:20:21,678
And this is 1 minus 0, $1
       minus $0, okay, so
减法 $1 - $0

469
00:20:21,680 --> 00:20:23,813
everyone cool here?
大家跟得上吧？

470
00:20:25,350 --> 00:20:27,483
These enums are really easy to
            create.
枚举简单地就能创建

471
00:20:27,485 --> 00:20:31,920
The API of them is really,
      really nice, simple.
它们的接口非常简单、漂亮

472
00:20:31,922 --> 00:20:34,055
And then we have our other
           operation,
接下来我们来看看其它操作

473
00:20:34,057 --> 00:20:37,058
which is our unary operation,
     which is square root.
一个一元操作——开方

474
00:20:37,060 --> 00:20:40,861
So let's put that in here,
   square root is right here.
那那个放这， 开方放这

475
00:20:40,863 --> 00:20:43,830
And we'll put it right here.
把它放这里

476
00:20:45,266 --> 00:20:48,267
And square root is not a
     binary operation it's
开方不是一个二元操作，而是一元操作

477
00:20:48,269 --> 00:20:49,601
a unary operation.

478
00:20:49,603 --> 00:20:53,738
Oops, look at all this.
看这

479
00:20:53,740 --> 00:20:56,591
'Kay?

480
00:20:56,592 --> 00:20:59,443
And of course, inside here,
    it's square root of $0.
当然，这里，它是 $0 的平方根

481
00:20:59,445 --> 00:21:01,745
Okay, you remember that from
           last time.
跟z之前zh说的一样

482
00:21:01,747 --> 00:21:02,879
So this is good.
不错

483
00:21:02,881 --> 00:21:04,864
Now, while I'm here,
这里

484
00:21:04,865 --> 00:21:06,848
I wanna show you a couple
  things more about closures.
我再给大家介绍一些闭包相关的东西

485
00:21:06,851 --> 00:21:07,950
Okay.

486
00:21:07,952 --> 00:21:10,052
This, what is this curly
             brace?
看这里，这个大括号是什么？

487
00:21:10,054 --> 00:21:12,721
 It's a function that takes one
          argument and
这是一个接受一个参数，返回一个参数的函数

488
00:21:12,723 --> 00:21:14,356
returns one argument.

489
00:21:14,358 --> 00:21:16,308
And we know that
我们知道

490
00:21:16,309 --> 00:21:18,259
it's doubles because we're
  creating a unary operation.
我们创建一元操作，所以是 double

491
00:21:18,261 --> 00:21:21,962
And so, it's inferring the
       type here, right?
于是，它推出这里的类型，对吧？

492
00:21:21,964 --> 00:21:23,530
Everyone understand that?
大家都能理解吗？

493
00:21:23,532 --> 00:21:27,133
Well, there's another function
  that returns a function, or
这里有另外一个函数返回一个函数，或者

494
00:21:27,135 --> 00:21:28,901
 there's another function that
       takes a double and
一个函数接受一个 double

495
00:21:28,903 --> 00:21:31,570
returns a double, that does
          square root,
返回一个开方后的 double

496
00:21:31,572 --> 00:21:33,772
it's called square root.
称作 sqrt

497
00:21:33,774 --> 00:21:36,941
So inside here, we could just
        say square root.
所以这里，我们可以就说 sqrt

498
00:21:38,178 --> 00:21:40,811
Okay, we don't even need this
           business.
甚至不需要这个

499
00:21:42,881 --> 00:21:44,080
Just wanna emphasize that
需要强调的是

500
00:21:44,082 --> 00:21:45,515
we're just passing a function
             here.
我们在这里传入了一个函数

501
00:21:45,517 --> 00:21:47,450
     And it can be a named
          function, or

502
00:21:47,452 --> 00:21:49,518
    we could use these curly
            braces.

503
00:21:49,520 --> 00:21:52,754
   Now, this is really gonna
 freak you out, cuz watch this.

504
00:21:52,756 --> 00:21:57,091
 For times, there's a function
 that does times called times.

505
00:21:58,728 --> 00:22:00,728
             Okay.

506
00:22:00,729 --> 00:22:02,729
     So in Swift, all these
      operators, times and

507
00:22:02,732 --> 00:22:04,664
   all these things, are just
           functions.

508
00:22:04,666 --> 00:22:06,966
     They just happen to be
  specified in a way that says

509
00:22:06,968 --> 00:22:09,068
 that they can be infix, right,
        between the two

510
00:22:09,070 --> 00:22:11,370
  arguments instead of taking
 the arguments in parentheses.

511
00:22:11,372 --> 00:22:13,138
 And we do the same thing here
           with plus.

512
00:22:14,641 --> 00:22:16,074
        All right, plus.

513
00:22:16,076 --> 00:22:17,508
    Now, we can't do it with
           divide and

514
00:22:17,510 --> 00:22:20,378
   minus because the order is
           backwards.

515
00:22:20,380 --> 00:22:22,146
  Right, we put the things on
           the stack,

516
00:22:22,148 --> 00:22:23,513
 we pull them out backwards, so

517
00:22:23,515 --> 00:22:25,081
   we can't do it with those,
              but.

518
00:22:27,919 --> 00:22:31,086
 I just wanna emphasize, that's
     what's going on there.

519
00:22:31,088 --> 00:22:33,455
 Okay, so now we have this nice
           knownOps.

520
00:22:33,457 --> 00:22:34,222
     So we have this thing.

521
00:22:34,224 --> 00:22:36,724
        It's loaded up.

522
00:22:36,725 --> 00:22:39,225
 It gets loaded up whenever the
 CalculatorBrain gets created.

523
00:22:39,228 --> 00:22:41,612
      So that's all good.

524
00:22:41,613 --> 00:22:43,997
 Now we can use that down here
      in performOperation.

525
00:22:43,999 --> 00:22:47,134
 All right, so how are we gonna
 use this in performOperation?

526
00:22:47,136 --> 00:22:50,870
  Well, we basically wanna let
      the operation equal

527
00:22:50,872 --> 00:22:53,172
      knownOps sub symbol.

528
00:22:53,174 --> 00:22:55,240
             Okay?
  Someone passed us a symbol.

529
00:22:55,242 --> 00:22:56,641
 They're trying to perform this
           operation.

530
00:22:56,643 --> 00:22:58,810
 So this is either a plus or a
             times.

531
00:22:58,812 --> 00:23:00,111
   Hopefully an operation we
             know.

532
00:23:00,113 --> 00:23:02,747
 And we're gonna look it up in
           knownOps.

533
00:23:02,749 --> 00:23:05,683
 And the way we do that is with
  the subscript notation with

534
00:23:05,685 --> 00:23:06,650
      the square brackets.

535
00:23:06,652 --> 00:23:07,951
             Okay?
         That's how you

536
00:23:07,952 --> 00:23:09,251
     look something up in a
          dictionary.

537
00:23:09,254 --> 00:23:11,454
   But what might be kind of
       surprising to you,

538
00:23:11,456 --> 00:23:13,622
  what type do you think this
      would be, operation?

539
00:23:15,292 --> 00:23:17,959
 Any guesses, yeah, some people
  are saying the right thing.

540
00:23:17,961 --> 00:23:20,128
  You'd think this might be an
              Op,

541
00:23:20,130 --> 00:23:24,498
   because I'm looking up in
 knownOps right here, a string.

542
00:23:24,500 --> 00:23:27,134
  And so hopefully I'm getting
 an Op, but this is not an Op,

543
00:23:27,136 --> 00:23:30,971
  this actually is an Optional
              Op.

544
00:23:30,973 --> 00:23:33,173
    Okay, now why is that an
    Optional Op, because you

545
00:23:33,175 --> 00:23:35,541
 might be looking up something
      that's not in there.

546
00:23:35,543 --> 00:23:38,344
 And it has to return, oh, nil,
    sorry, couldn't find it,

547
00:23:38,346 --> 00:23:41,413
 so that's why it has to be an
     optional, is returned.

548
00:23:41,415 --> 00:23:43,015
        So a dictionary,

549
00:23:43,016 --> 00:23:44,616
 whenever you look up something
        in a dictionary,

550
00:23:44,618 --> 00:23:47,118
 it always returns an Optional,
      okay, either nil or

551
00:23:47,120 --> 00:23:50,655
 the type of thing you said was
    supposed to be in there.

552
00:23:50,657 --> 00:23:53,457
 So I'm gonna if let here, I'm
           gonna say,

553
00:23:53,459 --> 00:23:56,827
   if I'm able to look up my
   operation in my knownOps,

554
00:23:56,829 --> 00:23:59,696
  then I'm going to push it on
        to my op stack.

555
00:24:02,534 --> 00:24:03,232
             Okay.

556
00:24:03,234 --> 00:24:06,068
    Are you cool with that?

557
00:24:06,070 --> 00:24:08,303
          Make sense?

558
00:24:08,305 --> 00:24:10,171
             Okay.

559
00:24:10,173 --> 00:24:12,407
       Now, what's next?

560
00:24:12,409 --> 00:24:13,908
             Well.

561
00:24:13,910 --> 00:24:14,541
          Now we have.

562
00:24:14,543 --> 00:24:15,509
           Oh, well.

563
00:24:15,510 --> 00:24:16,476
 I'm gonna take a pause here to

564
00:24:16,478 --> 00:24:18,845
 talk a little bit about access
            control.

565
00:24:18,847 --> 00:24:20,697
             Okay?

566
00:24:20,698 --> 00:24:22,548
 Access control is about public
          and private.

567
00:24:22,550 --> 00:24:25,017
             Okay?
   What methods in this class

568
00:24:25,019 --> 00:24:27,353
  are public, in other words,
   other people can use them,

569
00:24:27,355 --> 00:24:30,022
    other classes in my code
     allowed to call them?

570
00:24:30,024 --> 00:24:31,189
  And what things are private?

571
00:24:31,191 --> 00:24:32,757
  My internal data structures
             that I

572
00:24:32,759 --> 00:24:34,458
   don't want people messing
             with?

573
00:24:34,460 --> 00:24:38,428
    Okay, so the way public
        private works in

574
00:24:38,430 --> 00:24:41,064
 Swift is kind of interesting.

575
00:24:41,066 --> 00:24:42,999
   You basically specify the
       things you want to

576
00:24:43,001 --> 00:24:45,935
 be private by putting the word
        private on them.

577
00:24:45,937 --> 00:24:47,569
  If you don't put any word on
             them,

578
00:24:47,571 --> 00:24:50,639
   then they're public inside
         your program.

579
00:24:50,641 --> 00:24:52,040
             'Kay?

580
00:24:52,042 --> 00:24:55,109
   And you only use the word
 public if you're shipping out,

581
00:24:55,111 --> 00:24:58,979
  like, a framework of objects
      to other people, and

582
00:24:58,981 --> 00:25:02,215
 you want stuff in there to be
 public outside the framework.

583
00:25:03,251 --> 00:25:04,684
 So I'm making some framework,

584
00:25:04,686 --> 00:25:07,153
  a bunch of objects that I'm
  trying to sell to people or

585
00:25:07,155 --> 00:25:09,555
   I get people to use to do
         something, and

586
00:25:09,557 --> 00:25:12,624
    of course I'm gonna have
 things where my objects inside

587
00:25:12,626 --> 00:25:14,192
 my framework can talk to each
             other.

588
00:25:14,194 --> 00:25:16,361
 There's no keyword needed for
             that.

589
00:25:16,363 --> 00:25:18,229
  Then I'll have things inside
        certain objects

590
00:25:18,231 --> 00:25:20,464
 that are private only to that
   object, I'll say private.

591
00:25:20,466 --> 00:25:24,267
 And them some of them might be
 public that the customer who's

592
00:25:24,269 --> 00:25:27,404
     buying my objects, my
      framework, can use.

593
00:25:27,406 --> 00:25:29,238
  Now, in this class we're not
   gonna be doing frameworks,

594
00:25:29,240 --> 00:25:30,840
  we don't really have time to
        get to that, so

595
00:25:30,842 --> 00:25:32,508
  we're not gonna be using the
        keyword public,

596
00:25:32,510 --> 00:25:34,076
    we won't ever use that,

597
00:25:34,078 --> 00:25:35,510
   because we don't have any
          frameworks.

598
00:25:35,512 --> 00:25:37,578
 But we are gonna use private.

599
00:25:37,580 --> 00:25:39,180
 And, starting with assignment
              two,

600
00:25:40,216 --> 00:25:42,516
  it's one of your evaluation
     criteria is gonna be,

601
00:25:42,518 --> 00:25:45,985
make private things private. OK?
让 private 的东西 private。

603
00:25:45,987 --> 00:25:47,453
So that is important to do.
所以这个很重要。

604
00:25:47,455 --> 00:25:48,354
And you could just say,
也许你会这么说，

605
00:25:48,356 --> 00:25:49,988
well, I like everything to be public.
呃，我喜欢所有东西都是 public 的。

606
00:25:49,990 --> 00:25:51,156
Well, that's bad.
这样很糟糕。

607
00:25:51,158 --> 00:25:53,391
Okay? If you make your internal structure public,
好吧？如果你让内部的 structure（结构体）public，

608
00:25:53,392 --> 00:25:55,625
and some other object in your program
然后它会和其他在你程序中的对象

609
00:25:55,628 --> 00:25:58,796
starts muck in with it and breaks your object, and
开始乱搞在一起，然后你的对象崩了，

610
00:25:58,798 --> 00:26:00,931
then you come to a new version of your program, and
然后你程序版本号就+1了，

611
00:26:00,933 --> 00:26:03,467
you change something, and now everybody's breaking.
然后你改变了一些东西，导致所有人都崩了。

612
00:26:03,469 --> 00:26:05,335
That's bad, okay, that's chaos.
然后就没有然后了。

613
00:26:05,337 --> 00:26:08,671
So the only things that want to be not private are things
所以只有当你想用来给别的类或对象提供支持的时候，

614
00:26:08,673 --> 00:26:11,507
that you're committing to sign up to support.
你才会想让它不是 private 的。

615
00:26:11,509 --> 00:26:14,677
So in this class, the only public things so
因此在这个 class 里面，目前为止唯一是 public

616
00:26:14,679 --> 00:26:17,279
far are the initializer.
的只有 initializer。

617
00:26:17,281 --> 00:26:18,513
Obviously, we want to allow people to
很显然，我们希望允许别人

618
00:26:18,515 --> 00:26:19,847
create a CalculatorBrain.
创建一个 CalcualtorBrain 的对象。

619
00:26:19,849 --> 00:26:21,349
That's clearly public.
这很明显是 public 的。

620
00:26:21,351 --> 00:26:25,385
Also pushing and performing operands and operations.
同样的，将运算符和数字压栈然后计算的这些操作。

621
00:26:25,387 --> 00:26:28,238
That's public. Okay?
这些都该是 public 的。

623
00:26:28,239 --> 00:26:29,889
Everything else, for now, I'm gonna make private.
其他的东西，目前为止，我都会让它们是 private 的。

624
00:26:29,891 --> 00:26:31,657
So I'm gonna make this private.
所以我将让这个 private 。

625
00:26:31,659 --> 00:26:33,592
Notice that if I make this private,
注意到当我把这个变成 private了以后，

626
00:26:33,594 --> 00:26:35,427
it's gonna start saying, whoa,
这边将会提示，喂，

627
00:26:35,429 --> 00:26:38,730
wait a second, this can't be public, you know, it can't be
等等，这不能是 public 的，你懂的，这不能是

628
00:26:38,732 --> 00:26:42,100
non-private because this is private and it uses it.
非 private 的，因为这个是 private 的，然后这个用了它。

629
00:26:42,102 --> 00:26:44,368
That's what this warning's gonna say right here, see.
这个位置将会出现一个警告，你们看。

630
00:26:44,370 --> 00:26:45,720
Property must be
Property 必须

631
00:26:45,721 --> 00:26:47,071
declared private because its type is private.
声明为 private，因为它的类型是 private 的。

632
00:26:47,073 --> 00:26:48,205
Okay, that's the type of this.
好的，这个就是它的类型。


633
00:26:48,207 --> 00:26:49,906
But I want this to be private anyway,
但是我无论如何都希望它是 private 的，

634
00:26:49,908 --> 00:26:52,742
this is my internal data structure, opStack.
这是我的内部数据结构，opStack。

635
00:26:52,744 --> 00:26:56,278
Now, knownOps is kind of an interesting one.
现在，knownOps 是个有趣的东西。

636
00:26:56,280 --> 00:26:58,614
Maybe I would want that to be public one day,
也许我某天心血来潮会想让它变成 public 的，

637
00:26:58,616 --> 00:27:01,650
because maybe I want people to use my CalculatorBrain and
因为也许我希望人们用我的 CalculatorBrain 然后

638
00:27:01,652 --> 00:27:03,685
teach it new ops.
教会它新的运算。

639
00:27:03,687 --> 00:27:05,386
That wouldn't be that unreasonable.
这并不是那么过分的要求。

640
00:27:05,388 --> 00:27:08,356
However, I'm not ready to support that functionality in
但是呢，我现在还没准备好让我的 CalculatorBrain

641
00:27:08,358 --> 00:27:09,456
my CalculatorBrain.
支持这个功能。

642
00:27:09,458 --> 00:27:12,059
I'm just not sure I wanna do it this way.
我只是还没确定我想这么做。

643
00:27:12,061 --> 00:27:13,827
Maybe I don't want this property to be public,
也许我不想让这个 property 变成 public 的，

644
00:27:13,829 --> 00:27:17,263
I might want to just have some functions to learn an op or
我也许希望只是有些函数去学习一个运算操作或者

645
00:27:17,265 --> 00:27:18,982
something like that, so
类似的东西，所以

646
00:27:18,983 --> 00:27:20,700
I'm just not sure, so I'm gonna start out private.
我只是不确定，所以我一开始就设为 private 的。

647
00:27:20,702 --> 00:27:23,268
And that's really, when you're designing APIs,
所以事实就是，当你在设计 APIs 的时候，

648
00:27:23,270 --> 00:27:24,536
you wanna kinda start out,
你总得找个地方入手，

649
00:27:24,538 --> 00:27:27,405
make it private first, and then open it up as you're
先让它是 private 的，然后等到你想要支持一些功能

650
00:27:27,407 --> 00:27:30,308
willing to support that functionality.
的时候，再让其变成 public 的。

651
00:27:30,310 --> 00:27:31,709
-Question? -Is the common view in
-问题？- [学生提问]


652
00:27:31,711 --> 00:27:34,278
Swift to make most instance variables private and
- [学生提问]

653
00:27:34,280 --> 00:27:36,980
use getters and setters, or is it to make them, if,
- [学生提问]

654
00:27:36,982 --> 00:27:38,882
if they are supposed to be public, or
- [学生提问]

655
00:27:38,884 --> 00:27:40,683
make them public and then let the?
- [学生提问]

656
00:27:40,685 --> 00:27:43,052
All right. So the question is, is it,
好的。那么问题就是，

657
00:27:43,054 --> 00:27:45,854
is it kind of part of the Swift way to make
是不是有比较 Swift 的方式去让

658
00:27:45,856 --> 00:27:47,889
most instant variables private and
实例变量是 private 的，然后

659
00:27:47,891 --> 00:27:50,75
then have getters and setters that are public to get them.
用 public 的 getters 和 setters 去获取他们。

660
00:27:50,761 --> 00:27:52,226
That doesn't really even make sense in Swift.
这在 Swift 中甚至没有意义。

661
00:27:52,228 --> 00:27:53,961
That's more of an Objective-C thing.
这更像是 Objective-C 的方式。

662
00:27:53,963 --> 00:27:56,263
In Objective-C, you had instance variables, and
在 Objective-C 中，你有一个实例变量，然后

663
00:27:56,265 --> 00:27:59,032
then you had properties that would get and set them.
你有 properties ，会用getter 和 setter 去获得和设定它们。

664
00:27:59,034 --> 00:28:00,967
And Swift has kind of merged those a little bit
然后 Swift 会把这些东西融合得

665
00:28:00,969 --> 00:28:05,638
closer together so that properties are really kind of
更紧凑些，所以 properties 事实上是一种

666
00:28:05,640 --> 00:28:08,907
the public or private getters and setters.
public 或者 private 的 getters 和 setters。

667
00:28:08,909 --> 00:28:11,043
So, if you have a property, you just have to
因此，如果你有一个 property，你只需要

668
00:28:11,045 --> 00:28:13,178
decide whether you want people to access it or
决定你是否想要别人能够存取它，

00:28:13,180 --> 00:28:15,246
not, and if not, make it private.
如果不是，将它变成 private。

670
00:28:15,248 --> 00:28:16,681
And if so, make it public.
如果是，将它变成 public。

671
00:28:16,683 --> 00:28:19,350
And that, you know, don't make it non-private, basically.
然后，你知道，一般来说不要让它是非 private 的。

672
00:28:19,352 --> 00:28:21,685
And that's, just that's all you need to think about.
再然后呢，这将都是你所需要考虑的。

673
00:28:21,687 --> 00:28:24,854
I wouldn't even think in Swift in terms of instance variable
我甚至不会在 Swift 中考虑实例变量

674
00:28:24,856 --> 00:28:26,289
versus the property.
和 property 的区别。

675
00:28:26,291 --> 00:28:28,557
Now, it is still possible in Swift to do that,
现在，用 Swift 还是有可能做到的，

676
00:28:28,559 --> 00:28:30,526
because you have computed properties.
因为你有 computed properties（计算属性）。

677
00:28:30,528 --> 00:28:32,328
And those could be setters and
然后这些都可以成为设置 private properties

678
00:28:32,329 --> 00:28:34,129
getters that are setting private properties.
的 setters 和 getters。

679
00:28:34,131 --> 00:28:36,464
But we're gonna see on Wednesday, even,
但是我们将会在周三看到，甚至

680
00:28:36,466 --> 00:28:39,634
I'm gonna talk to you a little bit about a way that when your
我将会和你们说一点点关于

681
00:28:39,636 --> 00:28:41,902
properties get set, you can intervene,
properties 的 get 和 set，你可以介入，

682
00:28:41,904 --> 00:28:44,571
you can check them to make sure the value is okay.
你可以检查它们，保证它们的值是正常的。

683
00:28:44,573 --> 00:28:46,373
So if you have a public property,
所以如果你有一个 public 的 property，

684
00:28:46,375 --> 00:28:49,142
you can still protect it by intervening a little bit
当人们设了它的值或者尝试获取它的值，

685
00:28:49,144 --> 00:28:51,110
when people set it or try and get it.
你仍然可以介入一点点来保护它。

686
00:28:51,112 --> 00:28:52,912
So it is possible to still have some protection there,
所以有可能会有些保护机制在那里，

687
00:28:52,914 --> 00:28:53,545
we'll see that.
我们都会看到的。

688
00:28:56,016 --> 00:28:57,749
All right, so these are our only public things.
好啦，所以这些就是我们仅有的 public 的东西。

689
00:28:57,751 --> 00:29:00,651
Now, there's only one other public thing we need to do in
那么现在，这里还剩一个 public 的东西要

690
00:29:00,653 --> 00:29:02,420
our CalculatorBrain, which is,
在我们的 CalculatorBrain 里做的一些事情，这就是，

691
00:29:02,422 --> 00:29:04,688
we need to let people evaluate this stack.
我们需要求这个 stack 的值。

692
00:29:06,058 --> 00:29:09,492
So people are pushing operands and performing operations,
所以我们把操作符压栈然后进行运行，

693
00:29:09,494 --> 00:29:11,828
now they wanna know what's the result.
现在我们想知道结果是什么。

694
00:29:11,830 --> 00:29:14,129
Okay? They pushed an operand of a five.
好吧？我们往栈里压了一个数字5。

696
00:29:14,132 --> 00:29:15,898
They pushed an operand of a four.
然后我们再压一个数字4。

697
00:29:15,900 --> 00:29:18,166
They performed operation plus,
我们做加法操作，

698
00:29:18,168 --> 00:29:19,668
they want to see four plus five.
我们想看到的是4 + 5。

699
00:29:19,670 --> 00:29:21,202
Where's that nine, okay?
得到的答案应该是9，好吧？

700
00:29:21,204 --> 00:29:22,403
They need the result.
我们想要的是结果。

701
00:29:22,405 --> 00:29:25,606
   So we need another public
          method here,
   这里我们还需要一个公共方法，

702
00:29:25,608 --> 00:29:29,876
 which I'm gonna call evaluate.
 将其命名为 "evaluate"

703
00:29:29,878 --> 00:29:31,344
             'Kay?
         And evaluate,

704
00:29:31,346 --> 00:29:34,880
   we could have it return a
      double, for example.
像这样，我们可以设置其返回类型为 double

705
00:29:34,882 --> 00:29:38,917
   And it would just evaluate
        this opStack and
   这个方法会对 opStack 估值然后

706
00:29:38,919 --> 00:29:40,535
       return the value.
       返回结果

707
00:29:40,536 --> 00:29:42,152
 But I really can't make this a
            double.
但我不能设置这个 double

708
00:29:43,390 --> 00:29:46,524
   Really, this has to be an
           optional.
   事实上，它必须为 optional

709
00:29:46,526 --> 00:29:48,892
 'Kay, why does this have to be
          an optional?
为什么它必须为 optional ？

710
00:29:48,894 --> 00:29:52,295
  Well, that's because someone
 might get my CalculatorBrain,
这是由于，当某人拿到我的 "CalculatorBrain" 时，

711
00:29:52,297 --> 00:29:53,963
  and the first thing they do
              is,
他们如果第一时间

712
00:29:53,965 --> 00:29:55,932
  they say, perform operation
             plus.
说"执行加法"

713
00:29:55,934 --> 00:29:57,600
 Okay, well I have no operands.
但我们并没有可以被加的数

714
00:29:57,602 --> 00:29:59,051
             Okay?
              And

715
00:29:59,052 --> 00:30:00,501
   you're asking to evaluate
             plus.
可这个时候又被要求计算加法

716
00:30:00,504 --> 00:30:02,287
        I can't do that.
我不能执行这个操作

717
00:30:02,288 --> 00:30:04,071
 So, I have to return something
  to you, that lets you know,
所以我必须返回一些东西，让你知道，

718
00:30:04,074 --> 00:30:07,776
 I could not evaluate what you
      ask me to evaluate.
我无法计算你所需要我计算的东西。

719
00:30:07,778 --> 00:30:09,477
  So, I'm gonna return nil in
           that case,
在这种情况下，我就会返回 nil，

720
00:30:09,479 --> 00:30:12,213
  so valuate here really needs
       to be an optional.
这里确实需要返回一个 optional。

721
00:30:13,249 --> 00:30:14,848
  'Kay, so you can see some of
         the thinking,
你可以看到我们对于什么时候

722
00:30:14,850 --> 00:30:17,283
 when do you make something an
       optional when not.
应该使用 optional 的思考。

723
00:30:17,285 --> 00:30:19,285
   'Kay, so this is a classic
         case of that,
这里就是一个典型的使用场景，

724
00:30:19,287 --> 00:30:21,787
  where you got sometimes you
      wanna return it and
有时你想要返回一些东西，

725
00:30:21,789 --> 00:30:23,889
  you can't do it, so you have
         to return nil.
但又无法返回的时候，那么就返回 nil.

726
00:30:23,891 --> 00:30:28,793
 All right, so how we going to
      implement evaluate?
那么，接下来我们应该怎么实现 "evaluate" 呢？

727
00:30:28,795 --> 00:30:30,595
  Okay, how many people in the
             class,
对了，在这个班上有多少人

728
00:30:30,597 --> 00:30:34,365
 raise your hands don't be shy,
    are you comfortable with
不要害羞，举起你们的手，

729
00:30:34,367 --> 00:30:37,067
  the computer science concept
         of recursion?
有多少人熟悉计算机科学中递归的概念？

730
00:30:39,271 --> 00:30:40,903
             Okay.
 Excellent, that's about 80 or
很好，大概有80~90%，

731
00:30:40,905 --> 00:30:43,939
 90%, so I'm gonna explain this
       really fast then.
那么我将只是快速地解释一下

732
00:30:43,941 --> 00:30:45,974
  And if you don't understand
           recursion,
如果你不明白递归

733
00:30:45,976 --> 00:30:47,309
 if you didn't raise your hand,
如果你刚才没有举手的话

734
00:30:47,311 --> 00:30:48,843
 that's something you should go
            review.
那就意味着你需要回去复习

735
00:30:48,845 --> 00:30:50,378
             Okay?
      [LAUGH] Recursion is
递归是

736
00:30:50,379 --> 00:30:51,912
 something, you should know by
 the time you take this class,
当你在这个班级的时候，应该知道的东西。

737
00:30:51,915 --> 00:30:53,714
    so that's something you
     definitely wanna know.
这是你必须知道的。

738
00:30:53,716 --> 00:30:57,317
  So, how are we going to use
          recursion to
那么在这种情况下，

739
00:30:57,319 --> 00:30:59,252
      evaluate this stack?
我们应该怎样在 "evaluate" 中使用递归？

740
00:30:59,254 --> 00:31:00,653
  All right, looks like this.
好，看这里

741
00:31:00,655 --> 00:31:02,988
  I'm gonna do a sample stack,
          right here.
我将会在这里写一个堆

742
00:31:02,990 --> 00:31:08,393
 So, let's say I put a 6 on the
 stack, and then I put a 5, and
这样说吧，我放了一个6在这个堆上，然后我放了一个5，

743
00:31:08,395 --> 00:31:14,065
 then I put a plus, and then I
 put a 4, and then I put times.
然后我放了加号，然后我放了4，最后加上次数

744
00:31:14,067 --> 00:31:15,166
             Okay?

745
00:31:15,168 --> 00:31:17,968
  So here's our stack, and I'm
      gonna evaluate this,
这就是我们的堆，我将要计算这个

746
00:31:17,970 --> 00:31:18,702
      I'm gonna recursion.
      我将要使用递归

747
00:31:18,704 --> 00:31:19,769
    How am I gonna do that?
    我要怎么做？

748
00:31:19,771 --> 00:31:21,437
  Well, really, what I'm gonna
        do is I'm gonna
	  我要这样

749
00:31:21,439 --> 00:31:24,740
  have a helper method here, a
    recursive helper method.
在这里我需要一个帮助方法，一个帮助实现递归的方法。

750
00:31:24,742 --> 00:31:27,543
   I'm gonna call it evaluate
        also, actually.
事实上这个方法也叫 "evaluate"

751
00:31:27,545 --> 00:31:29,644
  And it's gonna take a stack,
        as an argument,
它会将我们的堆当做一个参数，

752
00:31:29,646 --> 00:31:31,012
 a stack of things to evaluate.
一堆用来计算的东西

753
00:31:31,014 --> 00:31:34,449
  And it's only gonna evaluate
  the top thing on the stack.
并且它只会计算处于这个堆顶部的元素

754
00:31:34,451 --> 00:31:36,717
 That's it just gonna value the
      top of the stack and
它只是计算处于堆中最上面的元素，并且返回，

755
00:31:36,719 --> 00:31:38,819
  return it, but the top thing
       of the stack might
但是计算堆栈最上的这个元素时，

756
00:31:38,821 --> 00:31:41,421
    involve looking at every
 single of one of these, right?
可能也会涉及到堆中的每一个元素

757
00:31:41,423 --> 00:31:44,157
 Cuz, this times needed to two
          operations.
因为，次数需要两个数才能进行。

758
00:31:44,159 --> 00:31:47,026
  So, lets look at this, this
 recursive evaluates gonna come
让我们再来看看，这个递归计算将要到这里来

759
00:31:47,028 --> 00:31:48,961
  in here, it's gonna try and
  将尝试着计算处于最顶部的元素

760
00:31:48,962 --> 00:31:50,895
 evaluate the top of the stack,
       which is a times.
       次数

761
00:31:50,898 --> 00:31:51,597
             Okay?
         So it's like,
将会像这样

762
00:31:51,599 --> 00:31:53,265
     okay, I'm doing times.
我在算次数

763
00:31:53,267 --> 00:31:56,101
   Now for times it needs two
            operate,
现在需要要找到两个数，

764
00:31:56,103 --> 00:31:58,302
  two operands here for times.
两个数用于计算次数。

765
00:31:58,304 --> 00:31:59,737
   So, it recursively calls,
它开始递归

766
00:31:59,739 --> 00:32:03,807
 itself to say give me to first
       operand for time.
它说给我第一个数作为次数。

767
00:32:03,809 --> 00:32:07,010
  And so recursively, comes in
     here, it finds a 4 on
然后就开始递归，在最顶端它找到了一个4，

768
00:32:07,012 --> 00:32:10,913
 the top it's like, I know how
     to evaluate 4, it's 4.
像这样，我当然知道怎样计算4，4次

769
00:32:10,915 --> 00:32:12,148
      So, it just returns.
所以直接返回

770
00:32:12,150 --> 00:32:15,751
  Okay, so now I have my first
           operands.
好，现在我就有了第一个操作数

771
00:32:15,753 --> 00:32:16,618
             'Kay?
              Now,
现在

772
00:32:16,620 --> 00:32:18,386
  I take the rest of the stack
              and
我把堆栈中剩下的数进行计算，

773
00:32:18,388 --> 00:32:21,255
 evaluate it, to get the second
              one.
用于得到第二个数。

774
00:32:21,257 --> 00:32:24,291
   And when I do that, I get
          plus, 'kay?
当我这样做时，我得到一个加号

775
00:32:24,293 --> 00:32:26,393
  So, plus says, oh, I have to
         evaluate plus.
然后加号说："噢，我要计算加法。"

776
00:32:26,395 --> 00:32:27,727
       It needs operands.
"那需要计算数才行"

777
00:32:27,729 --> 00:32:30,763
   So, I come over here, I'm
        getting a plus.
然后我就到这里来，我有了一个加号。

778
00:32:30,765 --> 00:32:34,700
    And I gotta go recursive
 again, to go get its operands.
我将再次递归，用于获取操作数。

779
00:32:34,702 --> 00:32:36,401
   I get the 5, that's good.
我得到5，很好。

780
00:32:36,403 --> 00:32:41,072
 I'm gonna go recursive again,
     get the 6, over here.
我还要再次递归，得到一个6，到这里来。

781
00:32:41,074 --> 00:32:42,907
  And I've evaluated the whole
             stack.
最后我将计算整个堆。

782
00:32:42,909 --> 00:32:45,876
 So, you see how I have to keep
 going backward recursively to
就这样，你看到我这样通过来回

783
00:32:45,878 --> 00:32:46,576
          my evaluate-
递归

784
00:32:46,578 --> 00:32:47,911
           >> [COUGH]

785
00:32:47,912 --> 00:32:49,245
 >> To get the operands for my
          operations.
获取计算所需要的操作数。

786
00:32:49,247 --> 00:32:51,848
  Once, I get to an operand I
           can stop,
一旦我取得了操作数，我就停下来，

787
00:32:51,850 --> 00:32:54,483
 okay number, I got it and I'm
        out of of there.
好的，数字，我得到了然后我要离开这里

788
00:32:54,485 --> 00:32:56,418
   But every time I encounter
       another operation,
但每一次我遇到另一个操作符时，

789
00:32:56,420 --> 00:32:58,153
      I have to keep going
         recursively to
我就必须继续递归来

790
00:32:58,155 --> 00:33:00,822
   get all my arguments, any
     questions about that?
获取所需要的参数，有人有疑问吗？

791
00:33:00,824 --> 00:33:06,327
  'Kay, so it's actually gonna
  be pretty simple recursion.
这就是一个非常简单的递归算法。

792
00:33:06,329 --> 00:33:08,862
 When you see the code, you're
  gonna be, that makes sense.
但你看到了代码，你就会觉得："哦，还真是这样"。

793
00:33:08,864 --> 00:33:12,832
    So, I'm gonna have this
 separate I'm gonna put this up
所以我将把这个放在最上面

794
00:33:12,834 --> 00:33:15,201
 on top for scrolling reasons.
为了更好地滚动。

795
00:33:15,203 --> 00:33:18,237
             Oops.
       Didn't mean that.
Opps，我不是故意地。

796
00:33:18,239 --> 00:33:19,672
     The separate evaluate.
这是分离的另一个 "evaluate"。

797
00:33:20,808 --> 00:33:25,677
 And this evaluate is going to
      take a stack of ops,
这个 "evaluate" 将会取得堆上的操作数，

798
00:33:25,679 --> 00:33:27,078
        as its argument.
作为参数。

799
00:33:27,080 --> 00:33:28,645
  And why does it take a stack
            of ops?
为什么他会获取堆上的操作数呢？

800
00:33:28,647 --> 00:33:31,048
   Because as it's recursing,
因为当他递归时，

801
00:33:31,050 --> 00:33:32,882
   it's using the rest of the
              ops.
   它使用剩下的op。

802
00:33:32,884 --> 00:33:34,050
    So, you see what I mean?
    所以，你们明白我的意思了吗？

803
00:33:34,052 --> 00:33:35,618
           It's not,
           它不是，

804
00:33:35,619 --> 00:33:37,185
 it can't be looking at the big
     opStack in our brain.
  也不可能在我们的大脑里面查看巨大的opStack。

805
00:33:37,188 --> 00:33:38,320
     It can't look at this.
     它不能这么查看。

806
00:33:38,322 --> 00:33:40,756
     'Kay, cuz it's kind of
         consuming it.
      因为这有点太消耗了。

807
00:33:40,758 --> 00:33:42,991
             Right?
    And every time I call it
    我每次递归调用

808
00:33:42,992 --> 00:33:45,225
   recursively, I'm gonna get
  fewer operands to work with.
  都只需要处理更少的操作数。

809
00:33:45,228 --> 00:33:46,194
   So this is what I'm doing.
   所以这就是我做的事情。

810
00:33:46,196 --> 00:33:47,962
 Now, the first time I call it,
 现在，我第一次调用，

811
00:33:47,964 --> 00:33:50,864
 right here, I'm gonna give it
       the full opStack.
 需要给出完整的opStack。

812
00:33:50,866 --> 00:33:53,767
 So, I'll call my recursive one
           from here.
 我从这里开始调用递归函数。
813
00:33:53,769 --> 00:33:56,036
  Now, what's this thing gonna
            return?
  那么，这里将要返回什么？

814
00:33:56,038 --> 00:33:56,836
             'Kay.

815
00:33:56,838 --> 00:33:57,770
     That's interesting and
     很有意思

816
00:33:57,772 --> 00:34:00,873
 here's a big new thing for you
            to see.
 而且这里有个很大很新的东西等待你们发现


817
00:34:00,875 --> 00:34:03,709
   You've read about it I, I
        can't remember I
   你们看过了吧，我不记得

818
00:34:03,711 --> 00:34:05,910
  even asked you to read about
      this but I think I.
  有没有教你们去看相关内容不过我。。我

819
00:34:05,912 --> 00:34:06,811
     No, I guess I didn't.
     不，我猜我没有。

820
00:34:06,813 --> 00:34:08,846
     Which is tuples, 'kay?
     什么是tuple（元组）？

821
00:34:08,848 --> 00:34:14,484
  So in Swift, you can combine
    multiple things together
    在Swift里，你可以把多个东西组合起来

822
00:34:14,486 --> 00:34:16,853
  into one kind of really te,
  成为一个相当。。
823
00:34:16,855 --> 00:34:19,922
  mini data structure called a
          tuple, 'kay?
  迷你的数据结构叫做tuple。

824
00:34:19,924 --> 00:34:22,124
 Don't let the tu [LAUGH] sound
       in there fool you.
 不要被tu的发音愚弄了。

825
00:34:22,126 --> 00:34:24,560
  It's not just two, it's any
         number, okay?
  这不是two，它可以是任意数目。
826
00:34:24,562 --> 00:34:26,762
   And you just put them in a
       parentheses, okay?
   你只需要把它们放进一对圆括号里。
827
00:34:26,764 --> 00:34:28,664
      And, and that's it.
      这就好了。

828
00:34:28,665 --> 00:34:30,565
 So you can use this for return
            values.
 你可以用它来做返回值。
829
00:34:30,567 --> 00:34:32,033
  So I've gotta function right
             here,
  我在这里使用了这一功能，
830
00:34:32,035 --> 00:34:34,735
 and I actually need to return
 two things from this evaluate.
 实际上我需要在求值后返回两个东西。
831
00:34:35,771 --> 00:34:37,754
             'Kay?
          One thing I
          一个是
832
00:34:37,755 --> 00:34:39,738
  need to return is the result
      of a evaluating it.
      求值运算的结果。

833
00:34:40,975 --> 00:34:43,042
     But the other thing I
     另一个

834
00:34:43,043 --> 00:34:45,110
 need to return is the rest of
  the stack that I didn't use.
  需要返回的是剩余未使用的栈。

835
00:34:45,112 --> 00:34:48,647
 Cuz as I'm working my way down
    here and I take off that
    因此就像我在这里演示的，

836
00:34:48,649 --> 00:34:52,884
  times, and the 4 and the 5,
 okay, I'm consuming things but
 我取走了乘号，然后是4跟5。我消费了东西，

837
00:34:52,886 --> 00:34:54,652
  then I'm leaving the rest of
         the stacks, so
  同时栈有剩余部分，

838
00:34:54,654 --> 00:34:56,920
    I have to keep returning
   what's left of the stacks,
   所以我需要在求值过程中

839
00:34:56,922 --> 00:34:58,722
  while we keep consuming it.
  返回栈的剩余部分。

840
00:34:58,724 --> 00:34:59,689
             Okay?

841
00:34:59,691 --> 00:35:01,958
 So, I'm gonna return this in a
             tuple.
 所以，我要在tuple里返回这个。

842
00:35:01,960 --> 00:35:04,126
  Tuples could not be simpler
            syntax,
  Tuple的语法不能再简单了，
843
00:35:04,128 --> 00:35:08,097
   just open parentheses, not
    nine, open parentheses.
   只要左括号，不是9，左括号

844
00:35:08,099 --> 00:35:11,066
 Open parentheses, and just all
      the types that you,
 然后是所有你要的类型数据
845
00:35:11,068 --> 00:35:12,634
   of things that you want in
             here.
   统统放在这里。

846
00:35:12,636 --> 00:35:14,569
 So, I'm gonna return a double
         question mark,
 所以我要在这里返回 double？

847
00:35:14,571 --> 00:35:16,070
       that's my results.
       这是我的结果。
848
00:35:16,072 --> 00:35:17,683
             'Kay?

849
00:35:17,684 --> 00:35:19,295
   That's what's eventually,
            gonna be
   这是最终

850
00:35:19,296 --> 00:35:20,907
  returned out here after all
     the recursion unwinds.
  所有递归都被展开后返回的结果。

851
00:35:20,910 --> 00:35:23,643
   And then also I'm going to
   同时我也需要

852
00:35:23,645 --> 00:35:28,348
   have the ops that are left
             over.
   剩下的op。

853
00:35:28,350 --> 00:35:32,851
  Now, a tuple could look just
      like this, unnamed.
  现在，一个tuple看上去像这样，未命名的。

854
00:35:32,853 --> 00:35:34,519
  Did you see how these things
         are not named,
  你们看到这些未命名的格式，

855
00:35:34,521 --> 00:35:35,920
 each of these things in here.
 里面每一个东西。

856
00:35:35,922 --> 00:35:38,956
 But you can also put names in
 here as, if you want, as well.
 如果你想要，也可以把名称放在这里。

857
00:35:38,958 --> 00:35:41,092
 So maybe I would call this one
          the result.
 所以大概我会把这个命名为result
858
00:35:42,061 --> 00:35:44,728
             Okay?
              And

859
00:35:44,729 --> 00:35:47,396
     I would call this one
      remainingOps, 'kay?
      把这个命名为remainingOps

860
00:35:47,399 --> 00:35:49,666
 And I kinda recommend putting
      those in there, and
 我推荐这么做，
861
00:35:49,668 --> 00:35:52,601
   you'll see why in a second
  because there's two ways to
  马上你门就会知道为什么 因为有两种方法

862
00:35:52,603 --> 00:35:56,138
 call a function that returns a
   tuple and get the results.
  来调用返回tuple的函数，拿到返回值。

863
00:35:56,140 --> 00:36:00,208
  And one of the ways requires
   that you name these, 'kay?
   其中一种强制要求命名。

864
00:36:00,210 --> 00:36:01,843
  So, it doesn't hurt to name
    the, you might, as well.
  所以，加上名字没什么妨害的。

865
00:36:01,845 --> 00:36:03,111
    It's good documentation.
    这是很好的文档。

866
00:36:03,113 --> 00:36:05,379
  Someone looking at this now
        knows, oh, yeah,
  有些人看到这里就会明白，对的，

867
00:36:05,381 --> 00:36:07,147
   this is the result of the
        evaluation, and
    这个是求值的结果，

868
00:36:07,149 --> 00:36:09,783
  these the ops that were left
             over.
  这个是剩下的op。

869
00:36:09,785 --> 00:36:10,784
             'Kay?

870
00:36:10,786 --> 00:36:13,419
           All right.

871
00:36:13,421 --> 00:36:15,121
     So let's dive in here.
     我们从这里开始。

872
00:36:15,123 --> 00:36:16,956
        The first thing,
        第一件事，

873
00:36:16,957 --> 00:36:18,790
 line of code I'm gonna put in
    this recursive function
 放在这个递归函数的代码，
874
00:36:18,793 --> 00:36:21,193
  is the failure line of code,
  处理失败的情况，

875
00:36:21,195 --> 00:36:25,930
   which is return nil, ops,
             okay?
   简单返回 （nil， ops）

876
00:36:25,932 --> 00:36:28,566
 So if I fail, okay, I'm gonna
            try and
  所以如果失败了，我会努力。。

877
00:36:28,568 --> 00:36:33,303
 do my best in here to evaluate
  these ops you passed me, but
  尽力在这里用传入的ops求值，

878
00:36:33,305 --> 00:36:36,272
    if I fail I'm just gonna
    return my result of nil.
    如果失败了，就以nil为结果返回。

879
00:36:36,274 --> 00:36:37,974
             'Kay?

880
00:36:37,975 --> 00:36:39,675
 And that's gonna be my default
      is to return nil so
 返回nil将是默认行为，
881
00:36:39,678 --> 00:36:40,643
        I know I failed.
        然后我就知道我失败了。
882
00:36:40,645 --> 00:36:42,344
  So, if I run out of operands
               or
  比如，我处理完毕所有的操作数，
883
00:36:42,346 --> 00:36:44,613
 I run out of stack can't find
             it for
 或者处理完毕整个stack，
884
00:36:44,615 --> 00:36:47,915
 example, it's just gonna fall
    out here and return nil.
 那么就会跳转这里返回nil。

885
00:36:49,152 --> 00:36:49,683
             Okay?

886
00:36:49,685 --> 00:36:50,784
        So that's good.
        这样挺不错的。

887
00:36:50,786 --> 00:36:52,619
 So, what do I need to do here?
 这里需要我做什么呢？

888
00:36:52,621 --> 00:36:56,089
 Well, first thing is I need to
   make sure I have some ops.
   首先我要确定这里有op。

889
00:36:56,091 --> 00:36:59,859
  So I'm gonna check to see if
     the ops is not empty.
  我要检查ops是不是空的。
890
00:36:59,861 --> 00:37:04,529
  Okay, if you've handed me a
 stack of no ops to evaluates,
  如果传入一个没有op的栈

891
00:37:04,531 --> 00:37:05,463
        I can't do that.
        我将无法求值。

892
00:37:05,465 --> 00:37:06,698
 So I'm just gonna return nil.
 我简单地返回nil。

893
00:37:06,700 --> 00:37:07,615
             'Kay?
               So

894
00:37:07,616 --> 00:37:08,531
  that's the very first thing,
  这是最开始要做的事，

895
00:37:08,534 --> 00:37:11,035
 I gotta make sure I have some
       ops to work with.
 我要确定我有待处理的op

896
00:37:11,037 --> 00:37:14,237
 Now, I'm gonna grab the first
      op of the stack, so
 现在，我要获取栈里的第一个op，
897
00:37:14,239 --> 00:37:16,639
   in this example, I'm gonna
    grab that x off of here.
    在这个例子里，我要在这里获取x。

898
00:37:16,641 --> 00:37:17,206
             'Kay?

899
00:37:17,208 --> 00:37:18,574
       I'm gonna do that,
       我这么做，

900
00:37:18,576 --> 00:37:24,012
  I'm gonna try to do that by
   saying, let op equal ops.
   这么实现： let op ＝ ops.

901
00:37:38,994 --> 00:37:40,594
that's how we do it, okay?
我们就会那样做，okay？

902
00:37:40,595 --> 00:37:42,195
We push things by putting these on the end of the array.
我们通过在数组的最后插入元素来压栈。

903
00:37:42,197 --> 00:37:44,196
We pop things by, by pulling it out.
我们再把它拉出来出栈。

904
00:37:44,198 --> 00:37:45,431
But you can see I got an error there.
但是，你们看到这里我犯了一个错误。

905
00:37:45,433 --> 00:37:48,166
[BLANK_AUDIO]

906
00:37:48,168 --> 00:37:49,768
And it's very important to understand why I
要理解为什么我在这里

907
00:37:49,770 --> 00:37:50,835
have an error here, okay?
犯了一个错误，这非常重要。okay?

908
00:37:51,838 --> 00:37:53,704
So I'm gonna click on it.
我点击这里。

909
00:37:53,706 --> 00:37:54,805
We're gonna read what it says,
我们看看它说什么。

910
00:37:54,807 --> 00:38:00,009
it says, immutable value of type array of op,
它说，数组中的 op 是不可变类型，

911
00:38:00,011 --> 00:38:04,113
only has a mutating member named removeLast.
只有一个不可变的元素，命名是 removeLast 。

912
00:38:04,115 --> 00:38:06,548
Okay, well this is kind of a formal way of saying,
Okay，好吧这只是一种“正式”的说法。

913
00:38:06,550 --> 00:38:13,221
you can't do removeLast on ops because ops is immutable.
你不能在 ops 数组中移除最后一个元素，因为 ops 是不可变的

914
00:38:13,223 --> 00:38:14,455
It's read-only.
它是只读的

915
00:38:14,457 --> 00:38:15,556
You cannot mutate it.
你不能改变它。

916
00:38:15,558 --> 00:38:16,990
You cannot change it.
你不能change它。

917
00:38:16,992 --> 00:38:20,160
Okay, why is ops read-only?
Okay，ops 为什么是只读的？

918
00:38:20,162 --> 00:38:23,063
Well, there's two things to think about here.
Well，这里有两个问题需要大家思考。

919
00:38:23,065 --> 00:38:26,899
One is, when you pass arguments into functions,
一个是，当你给方法传递参数时

920
00:38:26,901 --> 00:38:29,702
unless it's a class that you're passing,
只要你传入的不是一个类。

921
00:38:29,704 --> 00:38:32,137
unless you're passing an instance of a class.
只要你传入的不是一个类的实例。

922
00:38:32,139 --> 00:38:34,172
The thing you pass is copied.
那么你传入的参数就是拷贝过的。

923
00:38:34,174 --> 00:38:35,791
Okay?
Okay?

924
00:38:35,792 --> 00:38:37,409
It's very important to understand that,
弄明白这一点非常重要。

925
00:38:37,411 --> 00:38:38,876
that's passed by value.
就是传入的是值。

926
00:38:38,878 --> 00:38:40,845
You're used to it in other languages,
你在其他语言中习惯了这一点，

927
00:38:40,847 --> 00:38:43,313
most languages do this, pass by value.
大多数的语言是传递值的。

928
00:38:43,315 --> 00:38:46,516
Arrays and dictionaries are
not classes.
数组和字典不是类，

929
00:38:47,652 --> 00:38:49,952
They're not classes in Swift.
它们在 Swift 中不是类。

930
00:38:49,954 --> 00:38:50,886
They're structs.
它们是结构体。

931
00:38:50,888 --> 00:38:52,754
You know, like a C struct?
你知道的，就像 C 语言中的结构体。

932
00:38:52,756 --> 00:38:53,955
Okay?
Okay?

933
00:38:53,957 --> 00:38:55,723
Arrays and dictionaries are structs.
数组和字典是结构体。

934
00:38:55,725 --> 00:38:58,759
Structs in Swift look a lot like classes.
结构体在 Swift 中看起来很像类。

935
00:38:58,761 --> 00:39:00,594
They have functions,
它们有方法。

936
00:39:00,595 --> 00:39:02,428
they can even have properties that have storage.
它们甚至拥有带有存取方法的属性。

937
00:39:02,431 --> 00:39:04,865
They're almost identical to a
class, really.
它们几乎等同于一个类，真的。

938
00:39:04,867 --> 00:39:09,102
The only two huge differences between structs and classes.
这里的结构体和类仅有两大不同之处。

939
00:39:09,104 --> 00:39:12,638
One is that classes can have inheritance.
一个是，类可以继承。

940
00:39:12,640 --> 00:39:15,274
And structs cannot, okay?
但结构体不可以，okay？

941
00:39:15,276 --> 00:39:20,745
But number two is that structs are passed by value and
第二个就是，结构体传递的是值，

942
00:39:20,747 --> 00:39:25,049
classes are passed by
reference, okay?
而类传递的是引用，okay?

943
00:39:25,051 --> 00:39:27,751
Very important that you understand that distinction.
非常重要，你弄明白这里面的区别。

944
00:39:27,753 --> 00:39:30,687
So structs are usually only
used for basic.
因此结构体通常仅用于基础数据类型。

945
00:39:30,689 --> 00:39:33,289
You know, components like arrays and dictionaries.
你知道的，像数组和字典这样的元素。

946
00:39:33,291 --> 00:39:37,159
Even doubles and ints are
structs in Swift, okay?
甚至 double 类型和 int 类型在 Swift 中都是结构体。

947
00:39:37,161 --> 00:39:38,627
>> [COUGH]

948
00:39:38,628 --> 00:39:40,094
>> And that's great because
that means doubles and
这非常棒，因为这意味着 double 和

949
00:39:40,097 --> 00:39:42,564
ints can have functions on them and things like that,
int 也拥有方法和其他类似的语法，

950
00:39:42,566 --> 00:39:44,599
which we will see as the quarter goes by.
随着时间的推移我们可能会看到。

951
00:39:44,601 --> 00:39:46,501
But those things are all passed by values.
但是这里传递的都是值。

952
00:39:46,503 --> 00:39:48,669
So that's the first thing to understand is that this ops,
因此首先要做的事是

953
00:39:48,671 --> 00:39:52,139
when I call evaluate, whatever array of ops I pass to it,
理解当我调用 evaluate 方法，无论我传什么给 ops 数组。

954
00:39:52,141 --> 00:39:53,840
it's gonna be copied.
它都会被拷贝。

955
00:39:53,842 --> 00:39:55,108
Okay?
Okay?

956
00:39:55,110 --> 00:39:57,643
The second thing to understand here is that they're kind of
第二件事是理解在这里

957
00:39:57,645 --> 00:40:03,682
an implicit let in front of all things you pass.
在你传递的参数前面，实际上隐含了一个 let

958
00:40:03,684 --> 00:40:05,484
In other words, they're read-only.
换言之，它们是只读的。

959
00:40:05,486 --> 00:40:06,651
Make sense?
明白了吗？

960
00:40:06,653 --> 00:40:12,390
And a read-only array can't be mutated.
一个只读的数组不能被改变。

961
00:40:12,392 --> 00:40:14,475
I can't append things to it.
我不能给它添加元素。

962
00:40:14,476 --> 00:40:16,559
You can't remove things from it cuz it's read-only.
你不能从它身上移除元素，因为它是只读的。

963
00:40:16,562 --> 00:40:21,364
Now, I can actually put the word var here, okay?
现在，你实际上可以写一个 var 在这 ，okay？

964
00:40:21,366 --> 00:40:22,999
If I, sorry.
如果我...抱歉。

965
00:40:23,001 --> 00:40:25,267
If I put the word var here,
如果我写一个词 var 在这里。

966
00:40:25,269 --> 00:40:29,204
then ops inside here look no error.
那么 ops 在这个方法体里面看起来就没有错误了。

967
00:40:29,206 --> 00:40:32,674
Ops is a mutable array.
Ops 是一个可变数组了。

968
00:40:32,676 --> 00:40:34,575
It's still a copy though.
不过它仍然是一个拷贝。

969
00:40:34,577 --> 00:40:36,711
So they copied it, made it
mutable.
那么它们把 ops 拷贝成了一个可变的副本。

970
00:40:36,713 --> 00:40:41,381
And now inside here, I have a mutable copy to work with.
于是在这里面，有一个可变的拷贝在工作了

971
00:40:41,383 --> 00:40:45,084
Now, I'm not a big fan of doing that, kay?
但现在我不喜欢这么做，okay？

972
00:40:45,086 --> 00:40:46,118
Putting var up here.
写一个 var 在这里。

973
00:40:46,120 --> 00:40:47,586
I think it's a little confusing for readers of the code,
我认为这对于读代码的人会造成一些困惑，

974
00:40:49,222 --> 00:40:50,855
to understand exactly what's
going on there.
要确切地理解这里到底发生了什么。

975
00:40:50,858 --> 00:40:53,208
So, I'm not gonna do that,
因此，我不会这样做。

976
00:40:53,209 --> 00:40:55,559
instead, I'm gonna make a local variable here, which I'm
而是替换成一个局部变量在这里，

977
00:40:55,562 --> 00:41:00,865
gonna call remainingOps and
I'm gonna set it equal to ops.
命名为 remainingOps ，让 remainingOps 等于 ops 。

978
00:41:00,867 --> 00:41:03,000
Now, when you set equals like this,
注意，当你像这样赋值时，

979
00:41:04,103 --> 00:41:07,103
that copies it if it's not a class.
赋值的不能是一个类。

980
00:41:07,105 --> 00:41:08,571
Classes are all by reference.
类赋值的都是引用。

981
00:41:08,573 --> 00:41:09,438
It's exactly, what you would think.
就是这样，你们怎样想的。

982
00:41:09,440 --> 00:41:10,539
>> [COUGH].>> But anything else,但是别的，

983
00:41:10,541 --> 00:41:12,808
strucks or enums or anything else.
像结构体、枚举或者其他的什么。

984
00:41:12,810 --> 00:41:14,543
When you do equals here,
当你像这样赋值时，

985
00:41:14,544 --> 00:41:16,277
this is actually going to make a copy of this, and
实际上是做了，这个的拷贝，

986
00:41:16,279 --> 00:41:17,895
put it in here.
然后把它赋给这里。

987
00:41:17,896 --> 00:41:19,512
And since it's a var, it's
going to be mutable.
因为它是一个变量，所以它是可变的。

988
00:41:21,584 --> 00:41:23,083
Okay?
Okay?

989
00:41:23,084 --> 00:41:24,583
So now I have a mutable array of ops and
因此现在我有了一个可变数组 ops

990
00:41:24,586 --> 00:41:26,519
now I can say remainingOps.
现在我可以说 remainingOps

991
00:41:26,521 --> 00:41:27,854
Remove the last one.
移除了最后一个元素。

992
00:41:27,856 --> 00:41:30,122
And now I truly do have the remainingOps.
现在我真正有 remainingOps 了。

993
00:41:30,124 --> 00:41:32,358
I've removed the first thing in there.
我在这里移除了最后一个元素（"the first thing" 感觉像口误，校对请！）。

994
00:41:32,360 --> 00:41:35,594
[BLANK_AUDIO]

995
00:41:35,596 --> 00:41:38,463
Did everyone understand that little tidbit there?每个人都理解这个小技巧了嘛？

996
00:41:38,465 --> 00:41:39,464
Yeah? >> So there's a,Yeah？
Yeah? -（学生提问）

997
00:41:39,466 --> 00:41:42,800
like a, a unseen let in sort
of the opts?
-（学生提问）

998
00:41:42,802 --> 00:41:43,600
>> Yeah.>> Why isn't that like in
- Yeah. -（学生提问）

999
00:41:43,602 --> 00:41:47,371
front of doubles and
-（学生提问）

1000
00:41:47,373 --> 00:41:48,672
like ends or straightened
>> It is.
是的

1001
00:41:32,360 --> 00:41:35,594
         [BLANK_AUDIO]

1002
00:41:35,596 --> 00:41:38,463
  Did everyone understand that
      little tidbit there?
每个人都理解这个小技巧了嘛？

1003
00:41:38,465 --> 00:41:39,464
             Yeah?
        >> So there's a,
        -（学生提问）

1004
00:41:39,466 --> 00:41:42,800
  like a, a unseen let in sort
          of the opts?
          -（学生提问）

1005
00:41:42,802 --> 00:41:43,600
            >> Yeah.
   >> Why isn't that like in
   -（学生提问）

1006
00:41:43,602 --> 00:41:47,371
      front of doubles and
      -（学生提问）

1007
00:41:47,373 --> 00:41:48,672
   like ends or straightened
           >> It is.
是的

1008
00:41:48,674 --> 00:41:50,873
   So, the question is why is
  there not a kind of unseen,
所以，问题是：为什么不是一种看不见的

1009
00:41:50,875 --> 00:41:52,508
 let in front of all arguments?
 let 在所有的参数前面？

1010
00:41:52,510 --> 00:41:54,376
  Pretty much all arguments to
       functions kind of
       差不多所有的函数里的参数

1011
00:41:54,378 --> 00:41:55,577
 have that unseen let in there.
 都有个看不见的let 在那

1012
00:41:55,579 --> 00:41:57,545
   They're all read on, 'kay?
   这些都是默认的，OK？

1013
00:41:57,547 --> 00:41:59,681
  So and you could put var in
      front of any one and
      所以你可以把var放在任何一个参数前面

1014
00:41:59,683 --> 00:42:02,516
 turn it into a mutable copy of
              it,
              把这个变成可以在本地用的

1015
00:42:02,518 --> 00:42:03,484
  that you could use locally.
一个可变的复制。

1016
00:42:03,486 --> 00:42:04,885
     But if you only use it
            locally,
            但如果你在本地用这个

1017
00:42:04,887 --> 00:42:06,219
  it's not that great a thing.
  这不是个好事

1018
00:42:06,221 --> 00:42:08,371
             Okay?
             Okay？

1019
00:42:08,372 --> 00:42:10,522
  Now, there is a way to have,
  to pass by value things back
  现在，有一种通过值去获取、传递回来的方法

1020
00:42:10,525 --> 00:42:13,959
  out, but I'm not even gonna
        talk about that.
        但是我还没讲到

1021
00:42:13,961 --> 00:42:14,726
             Okay.
             Okay.

1022
00:42:14,728 --> 00:42:16,027
     You can read about it.
     你可以读到关于这些的东西

1023
00:42:16,029 --> 00:42:17,328
    It's this in out thing.
    这是这些在里面、在外面的事。

1024
00:42:18,698 --> 00:42:20,665
 I'm not even gonna talk about
              it.
              我还没有准备讲到。

1025
00:42:20,666 --> 00:42:22,633
 I really think it's better to
     stay within the value,
     我真的觉得还是在值上更好

1026
00:42:22,635 --> 00:42:25,035
     pass by value, pass by
     reference parameters.
     通过值和关系参数传递

1027
00:42:25,037 --> 00:42:27,604
    I think you can get more
    readable code that way.
    我想你可以通过那种方式来写出可读性更高的代码

1028
00:42:27,606 --> 00:42:30,139
 But there is a way, there is a
   way I'm not going to talk
   但是这里有种放在里面或是外面的基础方式

1029
00:42:30,141 --> 00:42:33,075
 about to do in out basically,
 prime numbers that go in out.
 我还没准备讲到，主数字放到里面或是外面的方式

1030
00:42:33,077 --> 00:42:33,842
             Yeah.
             Yeah

1031
00:42:33,844 --> 00:42:36,712
     >> Is there any way to
     －（学生提问）

1032
00:42:36,714 --> 00:42:39,180
          [INAUDIBLE]
          听不清

1033
00:42:39,182 --> 00:42:40,949
   >> Yeah that's what I just
             said.
             －（学生提问）

1034
00:42:40,950 --> 00:42:42,717
 There is a way to pass it kind
    of by reference in out.
    这里有一种方式、关联让值来回传递

1035
00:42:42,719 --> 00:42:44,618
 You know, you pass it in, you
           modify it,
           如果传入，就改变它

1036
00:42:44,620 --> 00:42:47,054
  and then it'll come back out
   when it's done at the end.
   在完成后、结尾时就会返回

1037
00:42:47,056 --> 00:42:48,255
    So, it's kind of like by
           reference.
           所以这就像是一种关系

1038
00:42:49,224 --> 00:42:50,323
  But the other thing you said
              is,
              但你说的另外一件事是

1039
00:42:50,325 --> 00:42:52,558
 oh this is terrible I'm making
        three copies of
        把这个值做了三次复制

1040
00:42:52,560 --> 00:42:55,394
 that dang thing, this must be
          super slow.
          真是一件很糟糕的事，会让程序变的非常慢

1041
00:42:55,396 --> 00:42:57,029
     And the answer is no.
     但答案是否定的

1042
00:42:57,031 --> 00:43:01,599
 Swift is super smart about not
      actually copying it,
      Swift是不会真的复制它的

1043
00:43:01,601 --> 00:43:04,135
   until you actually make a
         change to it.
         直到你真的改变它。

1044
00:43:04,137 --> 00:43:07,271
 So here when it passes a copy
      in it didn't really
      所以当传入一个复制的时候

1045
00:43:07,273 --> 00:43:10,073
 copy it, it just kinda passed
 a pointer in but it knows that
 并不是真的复制了，而是传入一种指针

1046
00:43:10,075 --> 00:43:13,576
  pointer is by, you know, not
  by reference it's by value.
  一种它知道从哪来的指针，而不是以值来关联

1047
00:43:13,578 --> 00:43:15,611
   And then when I copied it
          again here.
               然后我们再次在这复制

1048
00:43:15,613 --> 00:43:17,146
  It still didn't really copy
              it.
              这还是不会真的复制

1049
00:43:17,148 --> 00:43:19,081
 Even if this array had 10,000
         things in it,
         甚至这个数组里有一万条数据

1050
00:43:19,083 --> 00:43:21,116
 it didn't make 10,000 copy of
              it.
              它不会做一万次复制

1051
00:43:21,118 --> 00:43:25,019
    It was only here where I
       actually mutated,
       只有在这我会真的转变

1052
00:43:25,021 --> 00:43:26,120
   now it had to make a copy.
   现在这就必须复制了

1053
00:43:26,122 --> 00:43:28,989
 And it may not even have made
        an entire copy.
        并且这可能甚至不会做一个完整的复制

1054
00:43:28,991 --> 00:43:32,025
 It might have just kept track
  of the changes, for example.
   比如这可能留下改变的痕迹

1055
00:43:32,027 --> 00:43:33,860
  So, it's super smart behind
          the scenes.
          所以这真的非常智能

1056
00:43:33,862 --> 00:43:34,861
      Sweet to very smart.
      越智能越好

1057
00:43:34,863 --> 00:43:36,862
   So, don't worry too, about
         much about oh,
         所以我不是很担心

1058
00:43:36,864 --> 00:43:38,630
 I'm copying these things over
           and over.
           我一遍一遍的复制这些

1059
00:43:38,632 --> 00:43:40,332
  Swift is making the minimum
             out of
             Swift做了复制以外的

1060
00:43:40,334 --> 00:43:41,433
    actual copying going on.
    最少的事情

1061
00:43:41,435 --> 00:43:42,600
             Okay?
             Okay?

1062
00:43:42,602 --> 00:43:47,171
    All right, so now I have
      remainingOpts here,
      好的，现在这就有了remainingOpts

1063
00:43:47,173 --> 00:43:49,840
  which truly are my remaining
             opts.
             是真的保留的那个opts

1064
00:43:49,842 --> 00:43:51,842
             'Kay.
          Because I've
          因为我已经

1065
00:43:51,843 --> 00:43:53,843
  removed the top one, the x,
          off the top.
          把最上面的那个x从顶上移除了

1066
00:43:53,845 --> 00:43:56,279
    So now I've got all the
         remainingOps,
         所以我选择得到了所有剩下的remainingOps

1067
00:43:56,281 --> 00:43:59,181
  in this local variable here
      called remainingOps.
      在这个局部变量叫remainingOps

1068
00:43:59,183 --> 00:44:00,566
             Okay.
             Okay。

1069
00:44:00,567 --> 00:44:01,950
  Now, what am I gonna do with
   this op that I pulled off,
   现在，我现在要对这个已经取出来的op做什么呢？

1070
00:44:01,952 --> 00:44:03,218
    this one on the top, x?
    这个在顶上的x

1071
00:44:03,220 --> 00:44:06,621
     Well I'm gonna get the
     associated value from
     我想想从枚举中

1072
00:44:06,623 --> 00:44:07,888
           the enum.
           得到这个关联变量

1073
00:44:07,890 --> 00:44:11,792
             'Kay.
 Either this or these or this.
 无所谓是nayig

1074
00:44:11,794 --> 00:44:13,226
     And how do I do that?
     那么我该怎么做呢？

1075
00:44:13,228 --> 00:44:15,094
         I use Switch.
         我用Switch

1076
00:44:15,096 --> 00:44:17,496
  'Kay, I told you that Switch
      is really important.
      我告诉过你们Switch很重要

1077
00:44:17,498 --> 00:44:20,032
   And now you're seeing that
  Switch is really important.
  现在你们看到了他真的很重要

1078
00:44:20,034 --> 00:44:21,867
 Switch is how you pull things
              out,
              Switch用来把

1079
00:44:21,869 --> 00:44:23,668
    associated values out of
             enums.
             关联变量取出枚举

1080
00:44:23,670 --> 00:44:25,036
  So I'm just gonna switch on
            the op.
            所以我想在op上用switch

1081
00:44:25,038 --> 00:44:27,772
  'Kay, this is the op that I
      pulled off the top,
      这就是我从上面取得的op

1082
00:44:27,774 --> 00:44:30,708
  that x from the thing we did
         on the board.
         那个x就是我们之前在board上取得的

1083
00:44:30,710 --> 00:44:32,109
 And I'm just gonna look at the
           cases, so
           我只是看着这个case

1084
00:44:32,111 --> 00:44:35,412
 I have the case operand, okay.
 我得到了case的操作符

1085
00:44:35,414 --> 00:44:38,581
  Notice that it puts a little
     dot here because it's
     注意这里放了个小点

1086
00:44:38,583 --> 00:44:41,450
   really Op.Operand and it's
    using type inference to
    因为这应该是Op.Operand，并且用了类型接口

1087
00:44:41,452 --> 00:44:43,652
   know that it's Op.Operand,
             right.
             去知道这代表了Op.Operand

1088
00:44:43,654 --> 00:44:47,289
    Op.op, Op.Operand but it
   doesn't need the op there.
   Op.op, Op.Operand 但这里不需要op

1089
00:44:47,291 --> 00:44:50,892
  And here it's asking in this
  space, what do you wanna do
  这里在问，根据这个变量

1090
00:44:50,894 --> 00:44:54,628
  with the associated value if
   you're handling this case.
你想在这个case里做什么

1091
00:44:54,630 --> 00:44:56,864
   Where the enum is operand.
   哪个枚举是操作符

1092
00:44:56,866 --> 00:44:58,432
             'Kay?
             Okay?

1093
00:44:58,434 --> 00:45:04,037
    Well I want to let that
        associated value
        我想在那个关联变量前面放个let

1094
00:45:04,039 --> 00:45:10,175
   be assigned to a constant
        called operand.
        用来关联一个常量为操作符

1095
00:45:10,177 --> 00:45:11,510
             'Kay?
             Okay?

1096
00:45:11,512 --> 00:45:14,746
 And yes I could put var here,
 which would do the same thing,
 我当然也可以放歌var在这，也一样有用

1097
00:45:14,748 --> 00:45:17,715
 except for I could then change
       the thing in here.
       除非我之后把这里的东西改变了

1098
00:45:17,717 --> 00:45:20,685
  But I almost never wanna do
    this, almost always let.
    但我几乎从来都不会想做这事，几乎都用let

1099
00:45:20,687 --> 00:45:23,887
   So let operand means that
     inside the handling of
     所以let 操作符表示在这个case中的操作

1100
00:45:23,889 --> 00:45:27,157
 this case, 'kay, this case of
          the switch.
          这个switch中的这个case

1101
00:45:27,159 --> 00:45:30,693
 Inside here, operand is gonna
  have the associated value of

1102
00:45:30,695 --> 00:45:31,427
          the operand.

1103
00:45:32,430 --> 00:45:34,196
             'Kay?

1104
00:45:34,198 --> 00:45:35,897
   Oh, that's exactly what I
             want.

1105
00:45:35,899 --> 00:45:38,599
  I'm just gonna return right
   now I have to return this

1106
00:45:38,601 --> 00:45:40,301
       tuple right here.

1107
00:45:40,303 --> 00:45:42,569
   So I'm gonna returned the
            operand.

1108
00:45:42,571 --> 00:45:45,005
    That's the result, 'kay.

1109
00:45:45,007 --> 00:45:47,191
       When I go here and

1110
00:45:47,192 --> 00:45:49,376
 I encounter that next one down
 which was a four, I got a four

1111
00:45:49,378 --> 00:45:52,845
 I can just return that result
     to evaluate this one.

1112
00:45:52,847 --> 00:45:55,881
   And I also though have to
    return the remainingOps.

1113
00:45:57,018 --> 00:46:00,085
  'Kay, so I'm just returning
 the two values of this tuple,

1114
00:46:00,087 --> 00:46:02,754
   notice I don't have to put
        result colon and

1115
00:46:02,756 --> 00:46:06,390
 remaining opt colon in here it
   knows that those match and

1116
00:46:06,392 --> 00:46:07,224
    so it's still doing it.

1117
00:46:07,226 --> 00:46:09,159
    All right, makes sense.

1118
00:46:09,161 --> 00:46:13,763
  That's it for operand that's
       all I have to do.

1119
00:46:13,765 --> 00:46:15,064
     It's kind of a, in the
           recursion,

1120
00:46:15,066 --> 00:46:20,102
   it's kind of an end case.

1121
00:46:20,104 --> 00:46:21,069
             Yeah?
   >> Is remainingOps part of

1122
00:46:21,071 --> 00:46:22,520
       the stack or heap?

1123
00:46:22,521 --> 00:46:23,970
 >> This one here, or this one
             here?

1124
00:46:23,973 --> 00:46:24,989
       >> What in general
          [INAUDIBLE].

1125
00:46:24,990 --> 00:46:26,006
  >> Okay so, so the question
              is,

1126
00:46:26,009 --> 00:46:29,276
 when I do something like this,
     where is remainingOps?

1127
00:46:29,278 --> 00:46:30,377
       Is it in the heap?

1128
00:46:30,379 --> 00:46:31,812
      Is it on the stack?

1129
00:46:31,813 --> 00:46:33,246
    And the thing is, that's
     implementation detail.

1130
00:46:34,282 --> 00:46:36,148
  So, you, you don't know, but
        you don't care.

1131
00:46:38,018 --> 00:46:40,185
 All right, so that's operand.

1132
00:46:40,187 --> 00:46:42,020
   Operand was really, really
             easy.

1133
00:46:42,022 --> 00:46:44,321
    How about our operation,
        that's you, you,

1134
00:46:44,323 --> 00:46:46,090
   UnaryOperation right here.

1135
00:46:46,092 --> 00:46:49,659
 Now when we handle the case of
      the unary operation,

1136
00:46:49,661 --> 00:46:52,195
    we don't need that first
       associated value,

1137
00:46:52,197 --> 00:46:54,330
 that's the symbol, like plus.

1138
00:46:54,332 --> 00:46:56,332
 Okay well I'm evaluating here
     I don't care what this

1139
00:46:56,334 --> 00:46:58,500
  symbol is, I only care what
   the function is cause I'm

1140
00:46:58,502 --> 00:47:00,002
  gonna evaluate the function.

1141
00:47:00,004 --> 00:47:05,807
 So we can actually ignore this
 by putting in underbar, 'kay?

1142
00:47:05,809 --> 00:47:08,642
  Underbar in swift is kind of

1143
00:47:08,644 --> 00:47:12,212
   the universal I don't care
       about this thing.

1144
00:47:12,214 --> 00:47:14,681
  Okay and we're gonna see it
     other places we use it

1145
00:47:14,683 --> 00:47:16,549
 where it's kinda like, I don't
    really care about that.

1146
00:47:16,551 --> 00:47:18,251
  So you just put an underbar
             there.

1147
00:47:18,253 --> 00:47:19,819
   That way you don't have to
    declare a variable with

1148
00:47:19,821 --> 00:47:22,221
  some dumb name or something
           like that.

1149
00:47:22,223 --> 00:47:24,389
    Just put an underbar it
          ignores it.

1150
00:47:24,391 --> 00:47:25,323
             'Kay?

1151
00:47:25,324 --> 00:47:26,256
   But I do care about this.

1152
00:47:26,259 --> 00:47:29,794
  I'm gonna let that equal the
   operation that I'm doing.

1153
00:47:29,796 --> 00:47:30,361
             'Kay?

1154
00:47:31,397 --> 00:47:32,929
  Everyone, make sense there?

1155
00:47:32,931 --> 00:47:34,897
  So I'm ignoring the string,
              but

1156
00:47:34,899 --> 00:47:36,699
  I'm grabbing the operation.

1157
00:47:36,701 --> 00:47:40,402
  So here, what I wanna do is
 return and I'll try to do it,

1158
00:47:40,404 --> 00:47:41,370
 but I'm not gonna be able to.

1159
00:47:41,372 --> 00:47:45,540
   I'm gonna say, return this
         operation with

1160
00:47:45,542 --> 00:47:48,342
   its operand which I don't
             have.

1161
00:47:48,344 --> 00:47:51,512
 And there's some remaining ops
   that are leftover after I

1162
00:47:51,514 --> 00:47:52,579
        get the operand.

1163
00:47:52,581 --> 00:47:55,515
   So I'm kinda, I need to do
       some stuff here to

1164
00:47:55,517 --> 00:47:58,251
 be able to return what I want.

1165
00:47:58,253 --> 00:48:01,053
  The first thing I need to do
      is get the operand.

1166
00:48:01,055 --> 00:48:03,689
             'Kay?

1167
00:48:03,690 --> 00:48:06,324
  So, I did a unary operation
 let's say it was square root.

1168
00:48:06,326 --> 00:48:07,625
 I need to go back to the staff
              and

1169
00:48:07,627 --> 00:48:10,862
 pick off the next thing but I
           can't just

1170
00:48:10,864 --> 00:48:13,931
  assume that it's a number it
  might be more operations so

1171
00:48:13,933 --> 00:48:17,001
  I have to recurse, so here's
 where the recursion comes in.

1172
00:48:17,003 --> 00:48:20,103
 And I'm gonna show you how to
      call a function that

1173
00:48:20,105 --> 00:48:22,172
        returns a tuple.

1174
00:48:22,174 --> 00:48:25,274
 And get it's value up so this
  is important little example

1175
00:48:25,276 --> 00:48:27,677
  here, so there's two ways to
             do it.

1176
00:48:27,679 --> 00:48:30,279
 I'm gonna do it one way here,
           which is,

1177
00:48:30,281 --> 00:48:32,881
         I'm gonna let
       operandEvaluation,

1178
00:48:32,883 --> 00:48:37,919
 which is just a local variable
 that I'm inventing, equal call

1179
00:48:37,921 --> 00:48:43,057
 evaluate with the remainingOps
          that I have.

1180
00:48:43,059 --> 00:48:45,025
  'Kay, so here I've recursed.

1181
00:48:45,027 --> 00:48:46,459
      Okay, I'm recursing.

1182
00:48:46,461 --> 00:48:48,661
      And I just set it to
       operandEvaluation.

1183
00:48:48,663 --> 00:48:51,564
 Now, let's look at the type of
          this thing.

1184
00:48:51,566 --> 00:48:55,300
 If I look at its type, you can
     see that it's a tuple.

1185
00:48:55,302 --> 00:48:56,468
        That's its type.

1186
00:48:56,470 --> 00:48:58,770
      It's a tuple result
         remainingOps.

1187
00:48:58,772 --> 00:49:00,671
  It's this tuple right here.

1188
00:49:00,673 --> 00:49:03,140
    That is the type of this
       operandEvaluation.

1189
00:49:04,309 --> 00:49:06,242
 So now that I have that tuple,

1190
00:49:06,244 --> 00:49:09,245
 it's the result of evaluation
  how do I get the result and

1191
00:49:09,247 --> 00:49:13,716
   the remaining op out of it
 well I can get the operand by

1192
00:49:13,718 --> 00:49:19,621
 saying operand eval, [UNKNOWN]
   operandEvaluation.result.

1193
00:49:19,623 --> 00:49:21,423
             'Kay?

1194
00:49:21,424 --> 00:49:23,224
 So that just pull this is the
         tuple here I'm

1195
00:49:23,226 --> 00:49:26,227
   getting this value of the
      tuple out of there.

1196
00:49:26,229 --> 00:49:27,461
     Now what type is this?

1197
00:49:29,298 --> 00:49:29,863
            Anybody?

1198
00:49:30,865 --> 00:49:31,931
       It's an optional.

1199
00:49:31,932 --> 00:49:32,998
   You're pretty safe saying
        optional when I

1200
00:49:33,001 --> 00:49:34,099
  ask what type it is, aren't
              you?

1201
00:49:34,101 --> 00:49:35,801
     It's almost always an
           optional.
它总会是 optional           

1202
00:49:35,803 --> 00:49:37,168
   Cuz I usually don't ask if
           it's not.
因为如果它不是，我就不会问了

1203
00:49:37,170 --> 00:49:40,672
 But it is indeed an optional,
      an optional double.
它确实是个 optional，一个 optional double 类型的      

1204
00:49:40,674 --> 00:49:42,707
   It's this type right here,
             okay?
这就是它的类型             

1205
00:49:42,709 --> 00:49:46,043
  So we need to turn it into a
 double if we're gonna pass it
如果我们想把它传入这里， 

1206
00:49:46,045 --> 00:49:48,078
 to this operation right here.
就得把它变成一个 double 类型的

1207
00:49:48,080 --> 00:49:52,648
   So I'm gonna use if let to
    turn that into a double.
所以在这里我是用 if let 来把它变成 double    

1208
00:49:52,650 --> 00:49:55,084
             'Kay?

1209
00:49:55,085 --> 00:49:57,519
  Now, I can actually do this
  because I have the operand.
我确实可以这么做，因为我已经有了运算对象  

1210
00:49:57,521 --> 00:49:58,587
    Just got it right here.
从这里获取到的    

1211
00:49:58,589 --> 00:50:00,755
             'Kay?
   This is now a double, see?
它现在变成 double 了   

1212
00:50:00,757 --> 00:50:04,125
 And I can call this operation
          right here.
我可以在这里调用这个运算          

1213
00:50:04,127 --> 00:50:06,327
 And this is the remaining ops,
      but this has got to
这里是余下的 ops，但这里得放递归之后

1214
00:50:06,329 --> 00:50:09,229
 be the remaining ops after we
           recursed.
余下的 ops           

1215
00:50:09,231 --> 00:50:13,233
 So it's gotta be the remaining
 ops in this operandEvaluation.
所以它得是这个 operandEvalution 余下的 ops 

1216
00:50:13,235 --> 00:50:15,368
            So that
  operandEvaluation.remaining-
所以这里放 operandEvaluation.remainingOps  

1217
00:50:15,370 --> 00:50:19,471
              Ops.
   Everybody cool with that?
都懂了吗？   

1218
00:50:19,473 --> 00:50:21,206
         So that's it.
就是这样         

1219
00:50:21,208 --> 00:50:25,343
   It's just recurse, we just
   recursed to evaluate that.
我们为了计算而进行递归   

1220
00:50:25,345 --> 00:50:29,180
   If this fails if, if this
    recursion returned nil,
如果这步失败了，这次递归返回 nil    

1221
00:50:29,182 --> 00:50:31,849
  then this is, this, if let's
     not gonna happen this
这里都不会进行     

1222
00:50:31,851 --> 00:50:34,584
   return's not gonna happen,
 gonna fall all the way out and
不会 return，然后一路向下运行， 

1223
00:50:34,586 --> 00:50:37,454
  return nill which is what we
          want, 'kay.
最后返回我们期待的 nil          

1224
00:50:37,456 --> 00:50:39,522
    We failed in any of our
     recursive attempts to
如果为了得到运算对象

1225
00:50:39,524 --> 00:50:40,756
   get the operands we need,
递归失败了   

1226
00:50:40,758 --> 00:50:42,825
  we gotta fail all the way up
       to the top level.
就是一路失败到最顶层的递归       

1227
00:50:42,827 --> 00:50:46,028
         [BLANK_AUDIO]

1228
00:50:46,030 --> 00:50:48,063
   Okay now binary operation.
双目运算符   

1229
00:50:49,299 --> 00:50:52,466
   Also okay, let's do yeah,
       binary here case.
在这个 case 处理双目运算符       

1230
00:50:53,535 --> 00:50:54,267
            Binary.

1231
00:50:55,470 --> 00:50:57,570
   Obviously same exact thing
             here.
显然，跟上面一样             

1232
00:50:57,572 --> 00:50:59,438
   We don't care about that.
我们不需要关心这个   

1233
00:50:59,440 --> 00:51:00,906
    And here we're gonna let
           operation.
在这里，let operation           

1234
00:51:00,908 --> 00:51:03,708
 And we're gonna do the exactly
     the same thing we did
跟之前做相同的事情

1235
00:51:03,710 --> 00:51:06,577
 here but we just have to do it
   twice because we have two
但在这里得做两次

1236
00:51:06,579 --> 00:51:08,646
  operands to do here, through
             here.
因为我们得获取到两个运算对象             

1237
00:51:08,648 --> 00:51:15,052
 So let's let opp1Evaluation =
    evaluate(remainingOps).
所以，let opp1Evaluation = evaluate(remainingOps)

1238
00:51:16,088 --> 00:51:17,487
             'Kay.

1239
00:51:17,488 --> 00:51:18,887
     And then if we can let
           operand1 =
如果进行 let operand1 = op1Evaluation.result

1240
00:51:18,890 --> 00:51:20,756
     op1Evaluation.result.


1241
00:51:20,758 --> 00:51:23,625
 'Kay, then we got op1, that's
             good.
我们就获得了 op1             

1242
00:51:23,627 --> 00:51:27,262
 So now let's let op2Evaluation
               =
在这里 let op2Evaluation = evaluation(op1Evaluation.remainingOps)               

1243
00:51:27,264 --> 00:51:32,600
 evaluation(op1Evaluation.rema-
           iningOps).

1244
00:51:32,602 --> 00:51:36,370
             'Kay?

1245
00:51:36,371 --> 00:51:40,139
   And if we can let operand,
  oops, if we can let operand2
如果在这里 let operand2 = op2Evaluation.result  

1246
00:51:40,142 --> 00:51:44,844
  = op2Evaluation.result, then
             we can
我们就             

1247
00:51:44,846 --> 00:51:50,716
  return (operation(operand1,
           operand2).
return (operation(operand1, operand2))           

1248
00:51:50,718 --> 00:51:53,185
             'Kay?
              And

1249
00:51:53,186 --> 00:51:55,653
           we'll have
 op2Evaluation.remainingOps as
我们把 op2Evaluation.remainingOps 

1250
00:51:55,656 --> 00:51:57,355
       our remaining ops.
作为我们余下的 ops       

1251
00:51:57,357 --> 00:52:00,825
             Okay?
         [BLANK_AUDIO]

1252
00:52:00,827 --> 00:52:01,692
          Make sense?
我讲明白了吗？          

1253
00:52:01,694 --> 00:52:02,426
           All right.
          What's our.

1254
00:52:02,428 --> 00:52:03,159
     We have an error here.
在这里有个 error  

1255
00:52:03,161 --> 00:52:04,560
          What is it?

1256
00:52:04,562 --> 00:52:05,695
             okay.
             Yeah,

1257
00:52:05,696 --> 00:52:06,829
 this is a good error to cover
             here.
这个 error 值得一讲        

1258
00:52:06,831 --> 00:52:09,665
  See this it says method must
  be declared private because
它提到，这个方法必须声明为 private   

1259
00:52:09,667 --> 00:52:12,501
 this parameter uses a private
             value.
因为参数使用了 private 的值             

1260
00:52:12,503 --> 00:52:16,137
 And sure enough op is private
   so this has to be private.
op 是 private 的，所以这个方法得是 private 的   

1261
00:52:17,740 --> 00:52:19,273
             'Kay?

1262
00:52:20,476 --> 00:52:21,875
     Now notice by the way,
同时注意这里     

1263
00:52:21,877 --> 00:52:28,080
  I don't have default: break
      here in this switch.
这个 switch 我没有写 default: break      

1264
00:52:28,082 --> 00:52:30,215
  And why do I not have that?
我为什么没写？  

1265
00:52:30,217 --> 00:52:33,418
   Because I've handled every
     possible value of op.
因为我已经处理了 op 的每一个可能情形     

1266
00:52:35,088 --> 00:52:35,986
             'Kay?
         There are only
这里只有

1267
00:52:35,988 --> 00:52:37,254
       three kinds of op.
三种 op       

1268
00:52:37,256 --> 00:52:38,522
     I've handled them all.
我每一种都处理了     

1269
00:52:38,524 --> 00:52:40,374
  So I don't need any default.
所以我不需要 default  

1270
00:52:40,375 --> 00:52:42,225
  It wasn't like in the other
 one where we had a string and
这不像上一个处理 string 的 switch 

1271
00:52:42,227 --> 00:52:44,761
 we only handle a few strings,
    we had a default break.
我们只处理了几个 string，所以有 default: break    

1272
00:52:44,763 --> 00:52:47,863
 You don't put default break in
  when you handle every thing.
当你处理完所有情况，就不需要 default: break 了  

1273
00:52:47,865 --> 00:52:49,598
 And it's really bad programing
            style to
在每一个单独的 switch 语句

1274
00:52:49,600 --> 00:52:51,633
  put a default break in every
         single switch.
放一个 default: break 也是一种不好的编程风格         

1275
00:52:51,635 --> 00:52:54,903
 'Kay, you should only put them
    in on the ones where you
你只应该把它们放在你真想 break 的地方    

1276
00:52:54,905 --> 00:52:58,373
 truly are breaking because you
    can't handle every case.
因为你不能处理每一种情况    

1277
00:52:58,375 --> 00:53:00,574
             'Kay?
           All right.

1278
00:53:00,576 --> 00:53:03,844
 Now, the last thing we have to
 do is just call this recursive
现在要做的最后一件事就是 

1279
00:53:03,846 --> 00:53:06,113
       version from here.
调用这个递归       

1280
00:53:06,115 --> 00:53:08,782
  And I'm gonna call this one
              and
我要调用它，              

1281
00:53:08,784 --> 00:53:11,117
    get these tuple values a
      little differently.
用不一样的方式获取这些 tuple 的值

1282
00:53:11,119 --> 00:53:12,718
  I'm not gonna call it in the
         same way here.
我不会跟上次一样那么调用         

1283
00:53:12,720 --> 00:53:14,920
     I'm not gonna say, let
        something equal.
我不会这样        

1284
00:53:14,922 --> 00:53:20,091
  Instead I'm gonna say let a
 tuple which has let's call it
我会 let 一个 tuple ， 

1285
00:53:20,093 --> 00:53:24,062
   say (result, remainder) =
          evaluate and
像这样 (result, remainder) = evaluate          

1286
00:53:24,064 --> 00:53:28,666
    I'm gonna pass my whole
     (opStack) here, okay.
我要把整个 opStack 传进去     

1287
00:53:28,668 --> 00:53:31,668
 So this is a different way to
  call a function that returns
这里就是调用返回 tuple 的函数的不同方法  

1288
00:53:31,670 --> 00:53:35,305
 a tuple here you actually let
   a tuple equal the result.
其实是 let 一个 tuple 等于函数的返回值   

1289
00:53:35,307 --> 00:53:37,974
  Instead of letting a single
     thing equal result and
而不是让一个单独的东西等于返回值     

1290
00:53:37,976 --> 00:53:42,111
 then using the dots to get it,
 you let the tuple equal it and
然后使用 . 来获取元素， 你 let tuple = 

1291
00:53:42,113 --> 00:53:45,547
 notice that these names don't
  have to be the same as these
注意，这些命名不需要是一样的

1292
00:53:45,549 --> 00:53:48,283
  names so result is the same,
           but here I
result 是一样的，但是这里           

1293
00:53:48,285 --> 00:53:52,286
 use the word remainder instead
   of the word remainingOps.
我用 remainder 来取代 remainingOps   

1294
00:53:52,288 --> 00:53:53,754
  Okay they do not have to be
           the same.
它们没必要是一样的           

1295
00:53:55,024 --> 00:54:00,694
  And then here we just return
          our result.
在这里，返回我们的结果          

1296
00:54:00,696 --> 00:54:02,261
             Okay?

1297
00:54:02,263 --> 00:54:04,163
   So we learned a lot right
          there, okay.
在这里我们学到了很多          

1298
00:54:04,165 --> 00:54:05,297
    We learned about tuple,
我们学到了 tuple     

1299
00:54:05,299 --> 00:54:08,033
  passing you know things back
           tuples in
通过不同的方式获取 tuple            

1300
00:54:08,035 --> 00:54:13,237
 different ways you know how to
   ignore things in enums and
如何在 enum 里忽略一些东西   

1301
00:54:13,239 --> 00:54:15,106
when we're getting associate values all that stuff.
当我们得到关联值的东西。

1302
00:54:15,108 --> 00:54:16,974
So hopefully, you got all that.
所以希望你得到这一切。

1303
00:54:16,976 --> 00:54:19,676
I see a few people still kinda catching up on their typing.
我看到有些同学仍然在忙着敲代码

1304
00:54:19,678 --> 00:54:21,444
So I'll break for second here.
所以我会在这里等你们一下。

1305
00:54:21,446 --> 00:54:24,480
[BLANK_AUDIO]

1306
00:54:24,482 --> 00:54:27,283
[SOUND] So that's it that's the entire implementation of
这就是计算器

1307
00:54:27,285 --> 00:54:28,384
our calculator brain.
全部的实现过程。

1308
00:54:28,386 --> 00:54:30,919
It wasn't really that bad actually, right?
其实它并没有那么难理解，对吗？

1309
00:54:30,921 --> 00:54:33,722
Pretty simple little data structure here.
很简单的数据结构。

1310
00:54:33,724 --> 00:54:36,858
Just have to say what our known ops are.
只需要明确我们已知的 ops。

1311
00:54:36,860 --> 00:54:38,726
And have this recursion which
you know,
这种递归

1312
00:54:38,728 --> 00:54:42,196
actually is quite simple,
powerful code.
它其实就是一段很简单的功能很强大的代码。

1313
00:54:42,198 --> 00:54:44,031
If you're not comfortable with
your recursion I
如果你不满意你的递归

1314
00:54:44,033 --> 00:54:46,533
can see how it might be a little bit disturbing.
我可以帮你看下它哪里不合理

1315
00:54:46,535 --> 00:54:48,301
But go stare at it for
如果你多看看你的代码，

1316
00:54:48,302 --> 00:54:50,068
awhile and you'll, you'll get
it, how it works.
你就会明白它是怎么实现的。

1317
00:54:50,071 --> 00:54:51,921
Okay.

1318
00:54:51,922 --> 00:54:53,772
So, now that we've got this
new calculator brain,
现在我们完成了一个新的计算机

1319
00:54:53,775 --> 00:54:57,509
we have to use it in our old controller.
我们得把它用在之前的 controller 上

1320
00:54:57,511 --> 00:54:59,678
Okay, yeah question?
Okay，有什么问题？

1321
00:54:59,679 --> 00:55:01,846
>> Do we have to let like the op stack equal the remainder?
我们必须得让 opstack 等于 余数吗？

1322
00:55:01,848 --> 00:55:04,549
>> Do we have to let the op
stack equal the remainder?
我们必须得让 opstack 等于 余数吗？

1323
00:55:04,551 --> 00:55:05,349
Here, you mean?
是个意思吗？

1324
00:55:05,351 --> 00:55:05,916
>> Yeah.
对！

1325
00:55:07,119 --> 00:55:08,418
>> well, we're not gonna use remainder, so
呃，我们不会使用余数

1326
00:55:08,420 --> 00:55:10,620
actually, even I could put I
don't care here.
实际上，即使我可以用我也不用关心这里。

1327
00:55:10,622 --> 00:55:13,255
I only put that remainder
there to show you could have
我把余数放在这里是让你们知道

1328
00:55:13,257 --> 00:55:15,257
a different name, but I'm not
using the remainder.
你们可以起一个不同的名称，而不是去引用它。

1329
00:55:15,259 --> 00:55:16,892
I only want the result.
我只需要结果就好了。

1330
00:55:16,894 --> 00:55:19,861
You see.
>> Won't the op stack contain
明白了吗？
-在你计算它的值之前，

1331
00:55:19,862 --> 00:55:22,829
what was previously in it
before you evaluate it?
自定义的数据结构不会包含它吗？

1332
00:55:22,832 --> 00:55:25,016
>> Yes, the op stack will be
是的，但是这不会影响到自定义的数据结构

1333
00:55:25,017 --> 00:55:27,201
unaffected by this because op
stack is an array.
因为它是一个数组。

1334
00:55:27,203 --> 00:55:28,702
Arrays are passed by value so
数组是通过值传递的，

1335
00:55:28,704 --> 00:55:30,837
a copy of it gets passed into
here.
它的一个副本被传递到这里。

1336
00:55:30,839 --> 00:55:33,506
So this would be untouched and
which is what I want.
所以它不会改变，这正是我想要的。

1337
00:55:33,508 --> 00:55:36,242
I don't want evaluate to
consume my op stack.
我不想 evaluate 方法耗尽我的运算栈。

1338
00:55:36,244 --> 00:55:38,010
I wanna be able to call
evaluate over and
我希望它一遍又一遍的

1339
00:55:38,012 --> 00:55:38,744
over and over.
调用 evaluate 。

1340
00:55:38,746 --> 00:55:39,945
'Kay?
Especially if,
好吗？特别是,如果

1341
00:55:39,947 --> 00:55:43,581
I let's say introduced
variable operands and
我假设引入变量操作数

1342
00:55:43,583 --> 00:55:45,550
that's what you're homeworks
gonna be, then I wouldn't
留给你们当作业

1343
00:55:45,552 --> 00:55:47,685
want to change the variables
to different things and
而且我不想改变这些变量

1344
00:55:47,687 --> 00:55:49,520
be calling it over and
然后通过不同的值，比如变量

1345
00:55:49,521 --> 00:55:51,354
over with different values for
the variable for example and
一直调用它

1346
00:55:51,357 --> 00:55:53,690
then maybe next week I can
have an assignment where I'm
也许下周我可以有一项任务，

1347
00:55:53,692 --> 00:55:57,894
gonna make your graph such a
thing, which I'm going to do.
我会给你们画图表。

1348
00:55:57,896 --> 00:55:59,012
Okay?

1349
00:55:59,013 --> 00:56:00,129
So that's why I wanna do that.
所以，那是为什么我这么做。

1350
00:56:00,131 --> 00:56:02,131
So anyway, yeah, remainder
here can just be anything.
所以，这里的余数可以是任何值。

1351
00:56:02,133 --> 00:56:03,532
I'm actually gonna put this
here because we're
实际上，我把它放在这里，是因为

1352
00:56:03,534 --> 00:56:05,300
gonna print one this in a
second just so
我想打印它

1353
00:56:05,302 --> 00:56:06,567
we can get a better look at
what's going on.
这样我们就可以明白它内部如何运行的。

1354
00:56:06,569 --> 00:56:10,904
But first, let's go back to
our controller and use this
我们接着回到我们的 controller

1355
00:56:10,906 --> 00:56:14,007
calculator brain, this nice
model we just invented.
使用我们刚刚建立的 calculator brain  model

1356
00:56:14,009 --> 00:56:15,842
Let's use it.
Now,
我们开始使用它，现在

1357
00:56:15,843 --> 00:56:17,676
I'm gonna show you how to get
two things on screen at
我来教你们怎样让这两个页面同时

1358
00:56:17,679 --> 00:56:18,644
the same time.
显示在你的界面上。

1359
00:56:18,646 --> 00:56:20,880
That aren't necessarily
directly related.
它们之间不一定要直接相关。

1360
00:56:20,882 --> 00:56:23,549
Before we have the story board
and then I went up and
之前我们用 story board 的时候，移动鼠标

1361
00:56:23,551 --> 00:56:25,784
clicked this system editor
right here and
点击右上角的 editor 按钮之后

1362
00:56:25,786 --> 00:56:27,319
it showed me the controller.
它显示一个相关联的控制器。

1363
00:56:27,320 --> 00:56:28,853
Because the system editor
figured out that, oh,
由于系统的 editor 自动识别

1364
00:56:28,855 --> 00:56:30,388
if you have the story board up
you probably want
它自动显示和你选择的控制器

1365
00:56:30,390 --> 00:56:33,257
the controller for the scene
you have selected.
直接相关的 story  board 。

1366
00:56:33,259 --> 00:56:34,992
But here it's like, I don't
know what to show you.
但是现在，这里啥也不显示。

1367
00:56:34,994 --> 00:56:36,827
So I'm gonna show you a
different way to
所以我叫你们另外一种方法

1368
00:56:36,829 --> 00:56:39,229
get something in here, two
ways actually.
来显示控制器界面，实际上是两种方法。

1369
00:56:39,231 --> 00:56:41,931
One is if you go to this top
bar where
看没看见 top bar 上

1370
00:56:41,933 --> 00:56:44,667
it says counterparts, you can
mouse down and
counterparts 这个选项，

1371
00:56:44,669 --> 00:56:47,603
you can find all kinds of
things about this
点击它你会发现更多选项

1372
00:56:47,605 --> 00:56:50,272
like subclasses of this class
on the left.
比如左边类的子类

1373
00:56:51,341 --> 00:56:54,642
Superclasses of this [UNKNOWN]
class on the left.
他的父类

1374
00:56:54,644 --> 00:56:57,111
Of course it has no
superclasses or subclasses.
当然他没有任何子类或者父类。

1375
00:56:57,113 --> 00:57:00,547
But other things, things it
includes are included by it.
此外，还有被它包含或者包含它的一些文件。

1376
00:57:00,549 --> 00:57:02,115
You can also just manually go
in.
你也可以手动去找。

1377
00:57:02,117 --> 00:57:03,283
We can go over here for
example and
比如我们可以在里面浏览

1378
00:57:03,285 --> 00:57:06,152
find our view controller and
load it up that way, but
找到目标控制器，并且加载它。

1379
00:57:06,154 --> 00:57:09,088
I'm gonna show you a different
way than doing that
但是我还有另外一种方法。

1380
00:57:09,090 --> 00:57:11,423
which is to go over here to
your navigator.
打开左侧的导航条，

1381
00:57:11,425 --> 00:57:14,893
If you hold down Option and
press on
按住 option 键，同时点击

1382
00:57:14,895 --> 00:57:18,663
a file like ViewController it
will appear on the right.
一个文件，比如这个 ViewControlle ，它就会显示在右边。

1383
00:57:18,665 --> 00:57:20,464
'Kay?
看见没？

1384
00:57:20,466 --> 00:57:22,866
So Option clicking in here is
another good way to
所以，按住 Option 键

1385
00:57:22,868 --> 00:57:23,767
put things on the right.
再点击这里是个非常方便的方法。

1386
00:57:25,437 --> 00:57:27,320
Okay?
对吧？

1387
00:57:27,321 --> 00:57:29,204
So now here we have our
calculator brain on the left
现在  calculator brain 显示在左边，

1388
00:57:29,207 --> 00:57:31,040
and we have our controller on
the right,
同时 controller 显示在我们的右边。

1389
00:57:31,042 --> 00:57:34,943
we are going to rip out all of
the stuff in our
我们将删掉 controller 里的

1390
00:57:34,945 --> 00:57:39,180
controller that had to do with
being calculator.
一些可以被 calculator 代替的东西。

1391
00:57:39,182 --> 00:57:41,716
Okay, so that's all this stuff
right in here.
Okay，所以这东西就在这里。

1392
00:57:41,718 --> 00:57:43,484
'Kay.

1393
00:57:43,485 --> 00:57:45,251
All this calculating stuff, we
don't need any of this
这些计算的代码我们再也不需要了，

1394
00:57:45,254 --> 00:57:47,254
because those were only called from there.
因为那些代码只是在那边调用。

1395
00:57:47,256 --> 00:57:49,022
'Kay, so our controller's
getting quite simple,
okey，我们的 controller 变得更轻量级了，

1396
00:57:49,024 --> 00:57:50,757
our controller hardly has
anything left in it.
我们的 controller 几乎没有留下任何东西。

1397
00:57:50,759 --> 00:57:54,727
And that's because the UI only
needs this to be controlled.
这是因为 UI 只需要 controller 被控制的。

1398
00:57:54,729 --> 00:57:56,579
'Kay?

1399
00:57:56,580 --> 00:57:58,430
We also don't need our operand
stack because the brain is
我们也不需要我们的操作数栈，因为 brain

1400
00:57:58,432 --> 00:58:00,766
gonna do that.
因为 calculator brain  model 会处理这些东西。

1401
00:58:00,767 --> 00:58:03,101
   However, we do need a new
     instance variable here

1402
00:58:03,103 --> 00:58:04,903
 which is the calculator brain.

1403
00:58:05,905 --> 00:58:07,838
 Okay I'm just gonna create one
           like that,

1404
00:58:07,840 --> 00:58:12,676
 this is extremely common okay
            this is

1405
00:58:12,678 --> 00:58:16,680
 the green arrow that goes from
  the controller to the model.

1406
00:58:16,682 --> 00:58:18,948
 Remember that in our MVC talk
     that I did last time I

1407
00:58:18,950 --> 00:58:21,584
 said that the controller has a
   green arrow to the model,

1408
00:58:21,586 --> 00:58:24,386
 it can talk to it all at once,
     say anything it wants.

1409
00:58:24,388 --> 00:58:26,922
 This is essentially that green
             arrow.

1410
00:58:26,924 --> 00:58:29,591
 This is our model right here.

1411
00:58:29,593 --> 00:58:31,592
   And this is the controller
   this is how the controller

1412
00:58:31,594 --> 00:58:33,661
 talks to it through this thing
       we call the brain.

1413
00:58:33,663 --> 00:58:35,562
 Thing you can call it anything
          you want and

1414
00:58:35,564 --> 00:58:38,298
  of course this might be much
 more complicated green arrow,

1415
00:58:38,300 --> 00:58:40,767
 it might be a network database
  that is connecting to you to

1416
00:58:40,769 --> 00:58:41,934
         get the data.

1417
00:58:41,936 --> 00:58:43,102
             Okay?

1418
00:58:43,104 --> 00:58:45,671
 But in our case it's this very
      simple little brain.

1419
00:58:45,673 --> 00:58:47,206
             Okay.

1420
00:58:47,207 --> 00:58:48,740
   So now we don't need this
       either down here.

1421
00:58:48,742 --> 00:58:51,343
 This is where we're appending
     onto the op stack and

1422
00:58:51,345 --> 00:58:52,044
        printing it out.

1423
00:58:52,045 --> 00:58:52,744
     So we don't need that.

1424
00:58:52,746 --> 00:58:57,548
   But we do need an enter to
     push the operand onto

1425
00:58:57,550 --> 00:58:58,615
           the stack.

1426
00:58:59,718 --> 00:59:00,516
             Okay.

1427
00:59:00,518 --> 00:59:03,519
  So here I'm just gonna say,

1428
00:59:03,521 --> 00:59:08,657
  that I'm gonna say I'm just
             gonna

1429
00:59:08,659 --> 00:59:13,561
 say brain.pushOperand(display)
             value.

1430
00:59:13,563 --> 00:59:15,413
             'Kay?

1431
00:59:15,414 --> 00:59:17,264
  That's the main thing I need
    to do, is just do that.

1432
00:59:17,266 --> 00:59:21,902
  One thing though is, I also
   need to update my display.

1433
00:59:21,904 --> 00:59:23,870
    Because when I push this
            operand,

1434
00:59:23,872 --> 00:59:25,672
 that's gonna change the brain.

1435
00:59:25,674 --> 00:59:28,341
 I need to call that evaluate,
             right?

1436
00:59:28,343 --> 00:59:29,442
       And get the value.

1437
00:59:29,443 --> 00:59:30,542
 So I could call evaluate here,
              but

1438
00:59:30,544 --> 00:59:34,613
 actually, I'm gonna go back to
 my brain, and I'm gonna change

1439
00:59:34,615 --> 00:59:39,484
 pushOperand to return the va,
   the result of evaluating.

1440
00:59:39,486 --> 00:59:42,486
         Typing today.

1441
00:59:43,789 --> 00:59:46,623
    From it, from its, from
         internally, so

1442
00:59:46,625 --> 00:59:48,991
   I'm gonna return evaluate
             here.

1443
00:59:48,993 --> 00:59:50,593
 So that every time you push an
            operand,

1444
00:59:50,595 --> 00:59:52,127
     it'll just return the
          evaluation.

1445
00:59:52,129 --> 00:59:55,163
  Now one could argue whether
 this is the best thing to do.

1446
00:59:55,165 --> 00:59:57,932
  Because, you know, you might
      not be interested in

1447
00:59:57,934 --> 01:00:00,568
 the result of evaluating that
           right now.

1448
01:00:00,570 --> 01:00:03,671
   But it kind of feels to me
         kind of good.

1449
01:00:03,673 --> 01:00:05,339
     And it's not gonna be,

1450
01:00:05,341 --> 01:00:07,341
 there's not gonna be that many
      things on the stack.

1451
01:00:07,343 --> 01:00:10,143
 You're not gonna usually have
        calculator brain

1452
01:00:10,145 --> 01:00:12,712
   have 1,000 operations and
 operands, although you could.

1453
01:00:12,714 --> 01:00:14,013
  But you're not usually going
             to so

1454
01:00:14,015 --> 01:00:16,548
      it's probably not a
       performance issue.

1455
01:00:16,550 --> 01:00:19,751
  To have it just return this
 and it'll make caller's code,

1456
01:00:19,753 --> 01:00:22,320
    you know, look a little
            simpler.

1457
01:00:22,322 --> 01:00:24,522
  And if they don't want this
         return value,

1458
01:00:25,858 --> 01:00:27,808
 then they can just ignore it.

1459
01:00:27,809 --> 01:00:29,759
 They don't have to use it but
       I am gonna use it.

1460
01:00:29,762 --> 01:00:31,495
  So, when I push this operand
          right here,

1461
01:00:31,497 --> 01:00:35,798
  I'm gonna say, I'm gonna if
  let the results equal that.

1462
01:00:36,734 --> 01:00:38,000
     Okay, because it's an
           optional.

1463
01:00:39,036 --> 01:00:41,836
  And if it's not nil then I'm
             gonna

1464
01:00:41,838 --> 01:00:43,671
  set the display value to the
            result.

1465
01:00:43,673 --> 01:00:46,140
 So in other words, every time
       I push an operand,

1466
01:00:46,142 --> 01:00:49,343
 I'm gonna up my display value
      with the evaluation.

1467
01:00:49,345 --> 01:00:50,811
          Make sense?

1468
01:00:50,813 --> 01:00:53,446
 Okay, what if this comes back
              nil?

1469
01:00:54,982 --> 01:00:56,615
    So, I push something on,

1470
01:00:56,617 --> 01:00:59,151
    this is not gonna happen
  probably with Push Operand,

1471
01:00:59,153 --> 01:01:02,587
  but it might, and after your
       homework it might.

1472
01:01:02,589 --> 01:01:04,022
   So, what if I push and it
        comes back nil?

1473
01:01:04,024 --> 01:01:07,258
   Well, now I'm kinda stuck,
             okay?

1474
01:01:07,260 --> 01:01:10,728
 This is why, in your homework
  assignment, I suggested, wow

1475
01:01:10,730 --> 01:01:13,730
 wouldn't it be cool if display
    value took an optional.

1476
01:01:15,100 --> 01:01:17,600
  Right, if display value took
   and returned an optional.

1477
01:01:17,602 --> 01:01:20,769
    You could put something
  sensible in the display when

1478
01:01:20,771 --> 01:01:23,605
     you had something that
     couldn't be evaluated.

1479
01:01:23,607 --> 01:01:25,874
  So in assignment two making
       display value into

1480
01:01:25,876 --> 01:01:27,809
    an optional is gonna be
         required task.

1481
01:01:27,811 --> 01:01:29,977
 So you might as well do it for
         homework one,

1482
01:01:29,979 --> 01:01:33,447
 cuz you're gonna have to do it
    for homework two anyway.

1483
01:01:33,449 --> 01:01:35,182
             Okay.

1484
01:01:35,183 --> 01:01:36,916
  Just wanted to give you more
     time because I didn't

1485
01:01:36,917 --> 01:01:38,650
  really teach you the things
   about NumberFormatter and

1486
01:01:38,653 --> 01:01:41,320
  stuff in time for assignment
              one.

1487
01:01:41,322 --> 01:01:44,623
 But it's going to be required
 and that's because the best I

1488
01:01:44,625 --> 01:01:48,093
    can do here is maybe say
   display value equals zero.

1489
01:01:48,095 --> 01:01:50,962
 That's really lame but that's
       the best I can do.

1490
01:01:50,964 --> 01:01:54,432
  I really wanna say, display
      value was nil, okay.

1491
01:01:54,434 --> 01:01:56,634
    I really just wanna set
     display value equal to

1492
01:01:56,636 --> 01:01:58,953
      the result of this.

1493
01:01:58,954 --> 01:02:01,271
   And I wanna have nil, you
 know, clear out my display or

1494
01:02:01,274 --> 01:02:02,606
       in assignment two,

1495
01:02:02,608 --> 01:02:06,743
 extra credit, maybe it puts an
  error message in my display.

1496
01:02:07,912 --> 01:02:09,545
  Now that's extra credit, but

1497
01:02:09,547 --> 01:02:11,246
  that would be an even better
      thing to put there.

1498
01:02:12,216 --> 01:02:14,216
             Okay?

1499
01:02:14,217 --> 01:02:16,217
    But same thing for, for
     forming the operation.



1500
01:02:16,219 --> 01:02:17,652
   Here's our operation right
             here.
   这就是我们所做的操作。

1501
01:02:17,654 --> 01:02:21,005
    And I'm just gonna say,
    我要说的是，

1502
01:02:21,006 --> 01:02:24,357
 if I can let the result equals
  brains.performOperation of
如果把result 置为brain.performOperation()

1503
01:02:24,360 --> 01:02:27,361
  the operation that I got off
 the button, then I'm going to
 操作为松开按钮， 那么

1504
01:02:27,363 --> 01:02:29,963
   let my display value equal
          that result.
displayValue 应该等于之前所得的result值

1505
01:02:31,366 --> 01:02:34,667
 Otherwise I'm going to do the
       very lame thing of
否则， 我们将会做一件很差劲的事

1506
01:02:34,669 --> 01:02:38,904
  saying display value equals,
   whoops, value equals zero.
将displayValue的值置为0.

1507
01:02:38,906 --> 01:02:40,389
             Okay?
            Unders,
           明白了么？

1508
01:02:40,390 --> 01:02:41,873
  people understand why that's
         kind of lame?
   大家都懂为什么这么做很差劲么？

1509
01:02:41,875 --> 01:02:43,240
           All right.
	      好的
1510
01:02:45,644 --> 01:02:47,077
             Okay.

1511
01:02:47,079 --> 01:02:48,144
         So that's it.
	     至此，
1512
01:02:48,146 --> 01:02:49,812
     Look at how simple our
      controller is here.
 我们的controller的实现非常简单。

1513
01:02:49,814 --> 01:02:52,481
  It has almost no code in it,
             okay.
  里面几乎没有代码

1514
01:02:52,483 --> 01:02:54,550
 And that's really iOS is great
          about that.
   这就是ios开发的一个神奇之处。

1515
01:02:54,552 --> 01:02:56,885
 It really is pretty good about
          making it so
    这是一个非常棒的体验，

1516
01:02:56,887 --> 01:02:58,920
   that you can build your UI
     mostly graphically so
  你可以图形化的创建大部分UI

1517
01:02:58,922 --> 01:03:01,923
 that there's very little code
  to control what's going on.
 并且用非常少的代码来控制流程。

1518
01:03:01,925 --> 01:03:03,491
    And then even our model,
     对我们的模型来说，

1519
01:03:03,493 --> 01:03:05,759
   which is a pretty powerful
     calculator right now,
 目前是一个功能非常强大的计算器，

1520
01:03:05,761 --> 01:03:07,961
 we could add as many functions
        as we wanted to.
 我们可以随意添加各种方法

1521
01:03:07,963 --> 01:03:09,963
   It's just one liners here.
 只需要若干行代码

1522
01:03:09,965 --> 01:03:13,766
  And it would be capable of,
  you know, evaluating any se,
它就可以计算任何

1523
01:03:13,768 --> 01:03:15,334
     series of them that's
          evaluatable.
可计算的序列。

1524
01:03:15,336 --> 01:03:18,003
   And it's also set up to do
      your homework, okay,
这也是你们的作业，

1525
01:03:18,005 --> 01:03:19,738
     which is to add those
           variables,
添加这些变量，

1526
01:03:19,740 --> 01:03:22,140
  to be able to push operands
      that are variables.
把操作符作为变量压栈

1527
01:03:22,142 --> 01:03:25,309
 The other thing your homework
  is gonna ask you to do is to
另外一项作业 需要你们做的是，

1528
01:03:25,311 --> 01:03:28,112
   eval, to draw this, okay,
把这些公式的内容

1529
01:03:28,114 --> 01:03:30,848
 the contents of it in a human
         readable form.
转换成可读的形式

1530
01:03:30,850 --> 01:03:33,850
 Using infix notation like this
     with parentheses when
像这样 用中缀法

1531
01:03:33,852 --> 01:03:36,019
  necessary, things like that
              and
必要时配合括号使用等类似的方法。

1532
01:03:36,021 --> 01:03:37,820
  that's gonna be a lot easier
           here too.
在之前的铺垫后，这个作业相当容易完成

1533
01:03:37,822 --> 01:03:39,055
       Cuz you can recur,
因为你可以，

1534
01:03:39,056 --> 01:03:40,289
  use recursion, use recursion
     to build this as well.
使用递归来解决这个问题。

1535
01:03:41,559 --> 01:03:43,725
  Okay, so that's the main two
           things of
这就是我们的两个作业

1536
01:03:43,727 --> 01:03:44,693
 your homework that's what they
              are.
所要解决的主要问题

1537
01:03:44,695 --> 01:03:48,496
 All right, so let's see if we
 broke anything here all right,
现在来看看我们有没有出错的地方

1538
01:03:48,498 --> 01:03:50,064
 so we're gonna go up here and
              run.
单机此处运行，

1539
01:03:52,168 --> 01:03:53,834
  See if this all still works.
看是否仍然可以正常运行。

1540
01:03:53,836 --> 01:03:55,101
    Our UI has not changed.
我们的UI是没有变化的，

1541
01:03:55,103 --> 01:03:57,804
 You notice I never even opened
      the storyboard here.
你们可能注意到我在这里从来没有打开过storyboard。

1542
01:03:57,806 --> 01:03:59,005
      Didn't even open the
          storyboard.
甚至没有打开过storyboard

1543
01:03:59,007 --> 01:04:01,607
  Okay all these changes were
     pushing things out of
所有这些变动都会从

1544
01:04:01,609 --> 01:04:03,175
 the controller into the model.
controller流向model。

1545
01:04:03,177 --> 01:04:04,510
             Okay?
            The co,
好的

1546
01:04:04,511 --> 01:04:05,844
   communication between the
         controller and
所以， 控制器和视图

1547
01:04:05,846 --> 01:04:08,012
 the view has not changed here.
之间的交互没有发生改变。

1548
01:04:08,014 --> 01:04:10,915
   So hopefully this is gonna
     work let's try 85, and
我们试一下85， 希望可以成功运行

1549
01:04:10,917 --> 01:04:13,083
  our number entering is still
           working in
我们的数字输入依然在controller中，

1550
01:04:13,085 --> 01:04:15,252
  our controller that's good,
             Enter.
这是对的，

1551
01:04:15,254 --> 01:04:17,921
  Okay it still says 85 that's
             good,
好的，程序说明85是可以的。

1552
01:04:17,923 --> 01:04:22,224
   how about 41 plus seems to
      actually be working.
那么试一试41 ＋ ， 没有问题

1553
01:04:22,226 --> 01:04:23,325
          Square root,
开平方根，

1554
01:04:23,327 --> 01:04:26,861
   that's also working, nine
       times, excellent.
也没有问题， 再乘以9， 非常好

1555
01:04:26,863 --> 01:04:28,813
        That's working.
都可以得出正确结果。

1556
01:04:28,814 --> 01:04:30,764
  Now what if we do something
    that's not evaluatable?
现在，如果我们做一些不可计算的操作会怎样？

1557
01:04:30,767 --> 01:04:33,034
   I'm going to press times a
     whole bunch of times.
我输入很多个乘号，

1558
01:04:33,036 --> 01:04:33,901
             Right?
         Times, times.
✖️， ✖️，

1559
01:04:33,903 --> 01:04:35,736
      Oh, times no, zero.
得出了0

1560
01:04:35,738 --> 01:04:37,404
  See that's not really great
           feedback.
可以看出这不是一个好的反馈。

1561
01:04:37,406 --> 01:04:41,207
             Okay?
 But, it's not really zero but
不是真的0 但是

1562
01:04:41,209 --> 01:04:43,642
  it's, it's not good either.
也不是一个好的结果。

1563
01:04:43,644 --> 01:04:46,912
  So your homework is going to
   be printing out what's on
所以你们的作业是要

1564
01:04:46,914 --> 01:04:48,747
  the stack in a nice form so
将栈中的内容，以一个合适的形式打印出来

1565
01:04:48,749 --> 01:04:50,548
 you'll be able to see that you
       have times, times,
你们可以看到有很多乘号

1566
01:04:50,550 --> 01:04:53,918
 times, and it's gonna equal a
         blank display.
将会得到一个空的输出

1567
01:04:53,920 --> 01:04:56,353
  And that's gonna make sense
        that it's blank.
空的输出时比较合理的

1568
01:04:56,355 --> 01:04:57,020
             'Kay?
明白吗

1569
01:04:57,022 --> 01:04:59,422
           All right.
好啦

1570
01:04:59,424 --> 01:05:01,724
   Now, I wanna do one other
  thing here, though, just so
现在，我要做另外一件事，

1571
01:05:01,726 --> 01:05:03,659
    you can really visualize
        what's going on,
让你们可以真正将整个过程视觉化

1572
01:05:03,661 --> 01:05:05,561
  which is, I wanna print out,
那就是，

1573
01:05:05,563 --> 01:05:08,630
   when we evaluate, I wanna
     print out this stack.
在计算时， 我会打印出这些栈

1574
01:05:08,632 --> 01:05:10,265
  I wanna print out the thing
       we're evaluating,
我希望打印出我们在计算的东西

1575
01:05:10,267 --> 01:05:12,934
 I wanna print out the result,
   and I even wanna print out
打印结果， 甚至

1576
01:05:12,936 --> 01:05:14,702
  the remainder here so we can
      see what's going on.
希望打印出余数， 这样我们就可以看到整个流程

1577
01:05:14,704 --> 01:05:17,471
   So, I wanna say print ln.
所以， 使用println函数

1578
01:05:17,473 --> 01:05:21,841
  And I'm gonna say I'm gonna
  use my backslash thing here.
在这里用一个反斜杠

1579
01:05:21,843 --> 01:05:30,916
  Op stack equals result with
      how did I say this?
opStack 等于 result 加上...  应该怎么说，

1580
01:05:30,918 --> 01:05:32,685
    With [NOISE], oh, yeah.
呃..  对

1581
01:05:32,687 --> 01:05:36,688
 With our remainder left over.
加上留下的余数

1582
01:05:37,857 --> 01:05:39,507
             Okay.
好的

1583
01:05:39,508 --> 01:05:41,158
  So wouldn't it be cool if I
      could just do this.
我如果这样做会不会很酷？

1584
01:05:41,160 --> 01:05:44,361
  Just say, okay, the op stack
     evaluated equals this
opStack 等于

1585
01:05:44,363 --> 01:05:47,064
 result with the remainder left
             over.
结果加上余数

1586
01:05:47,066 --> 01:05:47,897
             Okay?
有问题吗？

1587
01:05:47,899 --> 01:05:48,765
        Let's run that.
我们运行程序，

1588
01:05:48,766 --> 01:05:49,632
  Do you think that's going to
             work?
你们认为会有问题吗？

1589
01:05:51,302 --> 01:05:52,468
             Maybe.
           Let's see.
可能有，我们来看看。

1590
01:05:52,470 --> 01:05:54,336
         [BLANK_AUDIO]

1591
01:05:54,338 --> 01:05:56,204
             Okay.
好的

1592
01:05:56,205 --> 01:05:58,071
 So let's try putting eight on
           the stack.
我们试试把8放入栈中，

1593
01:05:59,709 --> 01:06:01,375
             Okay?

1594
01:06:01,376 --> 01:06:03,042
 Let's make so we can see this
    over here, where is it,
我们把窗口放在中间，这样看的更清楚

1595
01:06:03,045 --> 01:06:06,213
    it's this probably right
      there, there it is.
大概在这个位置

1596
01:06:06,215 --> 01:06:08,114
  We don't need that one okay,
               so
我们不需要这个， 好

1597
01:06:08,116 --> 01:06:11,117
 here is our okay it's gonna be
        that, it's this.
这就是我们想要的结果

1598
01:06:11,119 --> 01:06:16,288
 Okay, so it said here hm, enum
 value in, in an array, equals
这里写着， 枚举值， 在一个队列中， 等于

1599
01:06:16,290 --> 01:06:21,860
  result of optional（8）, that's
   good, optional（ 8） is good.
把8传入optional函数的结果。optional （8） 是一个正确的结果。

1600
01:06:21,862 --> 01:06:23,161
    With nothing left over.
    没有其他余数

1601
01:06:23,163 --> 01:06:24,962
       Okay, that's good.
  Okay,没有问题。

1602
01:06:24,964 --> 01:06:26,397
       Let's go 6, Enter.
  点击6，然后点击 Enter

1603
01:06:26,399 --> 01:06:30,734
  Oh, now we have enum enum on
  the stack equals optional 6,
  哦，现在我们的栈里有两个 enum  一个赋值为 Opertional(6.0)

1604
01:06:30,736 --> 01:06:32,602
      with enum left over.
  另一个为 enum。

1605
01:06:32,604 --> 01:06:33,936
    Well that's not so good.
  哦，出问题了。

1606
01:06:33,938 --> 01:06:38,807
 Times enum, enum, enum equals
   it with, this is terrible.
  点击 X (乘号), enum, enum, enum 等于这个以及… 糟糕

1607
01:06:38,809 --> 01:06:40,342
  This is, I can't understand
        what the heck is
  这是回事？

1608
01:06:40,344 --> 01:06:41,342
         going on here.
  我不理解怎么会是这样

1609
01:06:41,344 --> 01:06:42,943
     Why is this happening?
  为什么会出现这些东西？

1610
01:06:42,945 --> 01:06:47,014
  Okay, when you put something
   in parentheses like this,
  Okay, 当你往圆括号中放类似这样的东西。

1611
01:06:47,016 --> 01:06:49,315
  it tries to convert it to a
            string.
  它试图将它转化为 string。

1612
01:06:49,317 --> 01:06:51,718
 Okay, well the thing that's in
       here is an array.
  但是括号里的东西却是一个 array。

1613
01:06:51,720 --> 01:06:54,520
   Arrays know how to convert
     themselves to strings.
  Array 知道怎么自己转化为 string。

1614
01:06:54,522 --> 01:06:57,623
 What they do is, they put open
        square bracket.
 Array所做的是，在最外层加上方括号。

1615
01:06:57,625 --> 01:07:00,759
   Then they ask every single
      thing in the array,
   然后要求 Array 里的所有元素

1616
01:07:00,761 --> 01:07:04,462
  convert yourself to a string
  'kay, and it puts them here.
  将你们自己转化为 string
  Okey, 然后 Array 将转换后的元素放在方括号中。

1617
01:07:04,464 --> 01:07:07,298
   Well our op is converting
     itself to this string.
  所以，op 将自己转化成了这个 string。

1618
01:07:07,300 --> 01:07:10,334
        Enum value 'kay?

1619
01:07:10,336 --> 01:07:12,670
   That's because the system
   doesn't really know how to
   这是因为编译系统并不知道

1620
01:07:12,672 --> 01:07:14,171
  convert it any other way so
  将它（op）转换为其他的类型。

1621
01:07:14,173 --> 01:07:15,872
   it's just saying that's an
          enum value.
   它（op）只是简单的说，这是一个 enum value。

1622
01:07:15,874 --> 01:07:18,241
 It doesn't know how to convert
      itself to a string.
 它（op）不知道怎么将自己转化为 string。

1623
01:07:18,243 --> 01:07:20,376
 So, you see, see what's going
            on here?
 现在，你知道这是怎么回事了吗？

1624
01:07:20,378 --> 01:07:24,146
 So, I'm going to show you how
       to teach a type to
 接下来，我将给你们示范怎么让一种类型

1625
01:07:24,148 --> 01:07:26,381
   turn itself into a string.
   将自己转换为 string。

1626
01:07:26,383 --> 01:07:28,716
    Okay, cuz that's really
   valuable for debugging and
   Okay， 因为这 debugging 非常有用而且

1627
01:07:28,718 --> 01:07:30,651
   also might be valuable for
         your homework.
   可能对你们的家庭作业有很大帮助。

1628
01:07:33,756 --> 01:07:35,356
   So, how we gonna do that?
   那么，该怎么做呢？

1629
01:07:35,357 --> 01:07:36,957
 All right, the way you do that
              is,
  方法就是，

1630
01:07:36,959 --> 01:07:42,595
   you have to add a computed
     property to your type.
   你需要为你的类型添加一个 computed property (计算属性)。

1631
01:07:42,597 --> 01:07:44,730
  And enums, just like structs
              and
  enums, 和 structs 和 classes 一样

1632
01:07:44,732 --> 01:07:47,599
 classes, can have properties,
             okay?
  也可以拥有属性，

1633
01:07:47,601 --> 01:07:50,435
  Only computer properties in
       enums, structs and
  只有在 enums, structs, 和 classes

1634
01:07:50,437 --> 01:07:53,104
  classes can have properties
        that are values.
 中的 computed properties (计算属性)可以有变量属性。

1635
01:07:53,106 --> 01:07:56,240
   Like these, like this over
        here, all right.
   比如这个，

1636
01:07:56,242 --> 01:07:57,408
 But they can only be computed.
  但是它们只能被计算

1637
01:07:57,410 --> 01:08:00,344
    You remember a computer
 property looks like this, var.
  一个 computed property (计算属性)应该是这样，var

1638
01:08:00,346 --> 01:08:01,929
        The name of it.
  computed property (计算属性)的属性名

1639
01:08:01,930 --> 01:08:03,513
      It has to be called
      description because
    它必须被称为 description，因为

1640
01:08:03,515 --> 01:08:05,081
     it's gonna be a string
       description of it.
    它将是成为它（computed property）的文字描述。

1641
01:08:05,083 --> 01:08:07,517
   The type has to be string.
   它的类型必须是 string。

1642
01:08:07,519 --> 01:08:09,418
  It's a string description of
              it.
  这是它的文字描述。

1643
01:08:09,420 --> 01:08:12,588
  And then of course you want
         your get here.
  然后，你必然需要 get 方法。

1644
01:08:12,590 --> 01:08:18,360
 And, whoops, your get and your
            set set.
  你的 get 方法和 set 方法。

1645
01:08:18,362 --> 01:08:21,896
  But it has to not only be a
       computer property.
  但是它不可能仅仅只是一个
  computed property。

1646
01:08:21,898 --> 01:08:24,165
 This description thing to make
           this work.
  为了让这个 description 起作用

1647
01:08:24,167 --> 01:08:26,900
   It wants to be a read only
              one.
   它需要是一个只读的属性。

1648
01:08:26,902 --> 01:08:28,068
 So we're not going to put the
              set,
  所以，我们不要 set 方法，

1649
01:08:28,070 --> 01:08:29,769
 so there will be no set, just
             a get.
  仅仅只有 get 方法。

1650
01:08:30,805 --> 01:08:36,108
 So this get just has to return
    this op as a string, so
  因此，这个 get 方法仅需将 op 作为 string 返回，

1651
01:08:36,110 --> 01:08:38,176
 I say someone turned it into a
            string.
  所以说得由其它人将它转化为 string。

1652
01:08:38,178 --> 01:08:40,045
 Well how would we turn our op
         into a string.
 我们到底怎么将 op 转化为 string。

1653
01:08:40,047 --> 01:08:44,749
 Well for the operations we're
 just gonna return the symbol.
  对于运算法则，返回运算符号。

1654
01:08:44,751 --> 01:08:47,484
     Okay if this is a plus
     operation turning into
    如果这是一个加法运算，将它转化

1655
01:08:47,486 --> 01:08:49,052
    string is I'm just gonna
         return a plus,
    为 string 的操作是返回 +（加号），

1656
01:08:49,054 --> 01:08:53,389
 cuz that pretty well describes
   a plus operation, a plus.
 因为一个加号很好的描述了一个加法操作。

1657
01:08:53,391 --> 01:08:55,224
        For the operand,
  对于操作数，

1658
01:08:55,225 --> 01:08:57,058
  I'm gonna have to turn this
     double into a string.
  我要将 double 类型 转化为 string。

1659
01:08:57,061 --> 01:08:58,627
        And return that.
  并返回这个 string。

1660
01:08:58,629 --> 01:08:59,528
   Okay so how am I gonna do
             that?
   我要怎么实现它呢？

1661
01:08:59,530 --> 01:09:03,131
    I'm gonna do that using
            switch,
    我要使用 switch 来实现它

1662
01:09:03,133 --> 01:09:05,867
  I need to switch on myself.
  我需要用 switch 为我自己处理分支。

1663
01:09:07,070 --> 01:09:09,837
   Okay cuz I'm gonna do this
 switch so that I can get these
  因为我要用 switch 所以我可以用这里

1664
01:09:09,839 --> 01:09:12,939
 same things out here, and you
 do the same thing I did here,
 相同的逻辑，你们得按我的来，

1665
01:09:12,941 --> 01:09:14,307
   see how I did this switch.
  注意我怎么实现这个 switch。

1666
01:09:14,309 --> 01:09:16,309
      So I could get these
     associated values out.
   以便我可以获取这些相关的值。

1667
01:09:16,311 --> 01:09:18,177
  I'm gonna do the same thing
             here.
  我将要在这里做相同的事情。

1668
01:09:18,179 --> 01:09:20,512
 So how do I switch on my self?
  我怎么为自己添加 switch？

1669
01:09:20,514 --> 01:09:23,415
       I say switch self.

1670
01:09:23,417 --> 01:09:24,716
             'Kay?

1671
01:09:24,718 --> 01:09:28,019
  And then I just have to say
     the case for operand.
  然后，我仅需要写下 self 是操作数的 case。

1672
01:09:28,021 --> 01:09:29,987
    And I'll let that be the
            operand.
   声明 operand。

1673
01:09:29,989 --> 01:09:33,657
 And I have to do the case for
        unary operation.
  然后，实现一元运算符的 case。

1674
01:09:33,659 --> 01:09:34,624
   Now when I do the case for
   当我处理二元运算符的 case，

1675
01:09:34,626 --> 01:09:37,493
  unary operation, I want the
            symbol.
  我需要运算符号。

1676
01:09:37,495 --> 01:09:40,529
   But I don't care about the
           function.
   但是我并不关心实际的运算。

1677
01:09:40,531 --> 01:09:42,831
   Cuz I'm not actually gonna
       compute anything.
  因为在这里我不会进行任何计算。

1678
01:09:42,833 --> 01:09:45,500
  I'm just going to return the
            symbol.
  我只是返回运算符。

1679
01:09:45,502 --> 01:09:47,469
  And then for binary options
             same,
 二元运算符也一样。

1680
01:09:47,471 --> 01:09:51,972
  same thing I want the symbol
     but I don't want this.
  我仅需要运算符，不需要这些。

1681
01:09:51,974 --> 01:09:53,307
 So that's the, the don't care.
  所以，忽略这些东西。

1682
01:09:53,309 --> 01:09:55,609
 And what am I gonna do in each
        of these cases?
 在每个 case 中我要做什么？

1683
01:09:55,611 --> 01:10:01,080
 Well in the operands case I'm
   gonna return a string that
  在 self 为操作数的 case 中，我将

1684
01:10:01,082 --> 01:10:02,848
        is that operand.
  返回这个操作数的 string。

1685
01:10:02,850 --> 01:10:06,251
  Oops, don't like the way it
     puts that extra thing
  Oops, 不喜欢编译器在这里添加额外代码的方法。

1686
01:10:06,253 --> 01:10:06,985
           on there.

1687
01:10:06,987 --> 01:10:08,286
             Okay.

1688
01:10:08,287 --> 01:10:09,586
     And then in the unary
       operation case I'm
   在一元运算的 case 中，我将

1689
01:10:09,589 --> 01:10:11,522
 just gonna return the symbol.
 返回运算符号。

1690
01:10:11,524 --> 01:10:13,390
  And in the binary operation
       case I'm also just
  在二元运算中，因为我不仅需要

1691
01:10:13,392 --> 01:10:14,224
    gonna return the symbol.
    返回运算符号

1692
01:10:14,226 --> 01:10:19,329
 And we have, oops, don't want
     the parentheses there.
 并且需要…（返回操作数, oops， 不需要这个括号。

1693
01:10:19,331 --> 01:10:22,965
  Kay and we've covered every
      case of this switch.
  Okay，我们覆盖了 switch 的每一个 case

1694
01:10:22,967 --> 01:10:25,735
 So not only does it know that
   this switch is covered but
   现在它（description）不仅知道这个 switch 列举了所有情况

1695
01:10:25,737 --> 01:10:28,604
 it knows that we for sure have
   returned something out of
 而且它知道我们肯定会从这里返回一些东西，

1696
01:10:28,606 --> 01:10:31,506
 here, because we only have one
    expression here which is
  因为我们这里只有一个表达式，即 swift（口误）， 不

1697
01:10:31,508 --> 01:10:34,909
  this Swift and switch and we
  know that covers every case.
  switch，并且我们知道 switch 覆盖了所有 case。

1698
01:10:34,911 --> 01:10:36,377
 So there goes so we have this
       nice description.
  现在，我们有了一个很好的 description.

1699
01:10:36,379 --> 01:10:40,814
  Now this is not quite enough
             'kay?
   但是，这还不够，

1700
01:10:40,816 --> 01:10:42,916
   You have to implement this
           property,
   比必须实现这个 property（属性），

1701
01:10:42,918 --> 01:10:44,784
     this computer property
           read-only.
这个 property 是只读的           

1702
01:10:44,786 --> 01:10:46,652
 But if you do one other thing,
但如果我们在这里 

1703
01:10:46,654 --> 01:10:50,456
 which is up here, you have to
     put, colon printable.
放一个 : printable     

1704
01:10:51,859 --> 01:10:56,961
   Now, I told you enums and
  structs have no inheritance.
enum 和 struct 没有继承  

1705
01:10:56,963 --> 01:10:58,696
  So you're like what, wait a
         second, there.
等一下，看这里         

1706
01:10:58,698 --> 01:11:01,098
 You're telling me op inherits
        from printable?
你竟然告诉我让 op 继承于 printable?        

1707
01:11:01,100 --> 01:11:04,234
 And the answer is no, does not
  inherit, okay, it's an enum.
不是这样的，这里不是继承  

1708
01:11:04,236 --> 01:11:07,070
      Enums don't have any
 inheritance, only classes do.
enum 没有继承关系，只有 class 有 

1709
01:11:07,072 --> 01:11:10,540
   What this colon printable
         means is, and
这个 : printable 代表         

1710
01:11:10,542 --> 01:11:12,842
  this can be true for classes
    or structs or whatever.
这个也可以对 class 或者 struct 有效    

1711
01:11:12,844 --> 01:11:14,643
  You can put after the colon
             here.
在这里写一个 :             

1712
01:11:15,713 --> 01:11:17,979
   This is called a protocol.
这个叫做 protocol   

1713
01:11:17,981 --> 01:11:21,215
  And all this means is you're
    telling Swift that this
这就代表，你告诉 Swift，    

1714
01:11:21,217 --> 01:11:24,852
 enum implements whatever is in
         this protocol.
这个 enum 需要自己实现这个 protocol 的内容         

1715
01:11:24,854 --> 01:11:28,389
  And this protocol happens to
      just be one computer
这个 protocol 恰好是 叫做 description 的 property 

1716
01:11:28,391 --> 01:11:30,590
  property called Description
    that returns the string.    
可以返回一个 string    

1717
01:11:31,826 --> 01:11:33,326
             Okay?

1718
01:11:33,327 --> 01:11:34,827
 Now we're going to talk about
      protocols in depth.
我们来深入了解一下 protocol

1719
01:11:34,829 --> 01:11:37,062
   Because protocols are very
         important for
因为 protocol 能够帮助我们了解，         

1720
01:11:37,064 --> 01:11:40,065
   explaining how things work
             'kay?
这到底是怎么一回事儿             

1721
01:11:40,067 --> 01:11:43,501
  But we're not gonna cover it
         today, though.
但是我们今天不会讲         

1722
01:11:43,503 --> 01:11:46,204
  Okay, so if you do those two
   things, put description in
如果我这么做，加上 printable

1723
01:11:46,206 --> 01:11:52,209
  printable, now when we run,
  you'll see, I'll go 5 enter.
再运行程序，5 enter，6,

1724
01:11:52,211 --> 01:11:54,511
  Six, and you see it's put a
         five in there.
你就会看到这里有个5         

1725
01:11:54,513 --> 01:11:55,512
          There's a 6.
这是6          

1726
01:11:55,514 --> 01:11:57,447
  Times, it's even putting the
             times.
times，它竟然把 times 也放进去了             

1727
01:11:57,449 --> 01:11:59,915
  If I hit times again, now I
          get nil and
如果我再点击 times，这里得到了 Nil      

1728
01:11:59,917 --> 01:12:03,652
 i tshows me the whole thing is
        leftover, okay.
所有的东西都余下了        

1729
01:12:03,654 --> 01:12:06,454
  Let's go another thing here,
再来一个测试

1730
01:12:06,456 --> 01:12:10,358
 what if I go 6 Enter 5 Enter 4
             Enter.
输入 6 enter 5 enter 4 enter

1731
01:12:10,360 --> 01:12:13,661
   Now if I do times it says
         times of 4 and
再做一次 times，它出现 4 * 5 = 20

1732
01:12:13,663 --> 01:12:18,098
 5 is 20 with the 6 left over,
         exactly right.
6 被剩下了，这都是正确的         

1733
01:12:19,134 --> 01:12:22,368
 Kay now notice I had to rerun
       there to do that,
为了这么做我得重新运行一次，       

1734
01:12:22,370 --> 01:12:24,303
   you're gonna have a clear
         button right,
你得在这里放置一个 clear button         

1735
01:12:24,305 --> 01:12:25,571
 that you do in assignment one,
      you're gonna have to
在作业一里的完成，      

1736
01:12:25,573 --> 01:12:27,239
  make that work in assignment
          two as well.
作业二里也得让它起作用          

1737
01:12:28,308 --> 01:12:31,309
 Okay the last thing really out
 of time but I'm gonna show you
最后一件事，尽管快没时间了 

1738
01:12:31,311 --> 01:12:34,311
 the last thing really quickly
   that I was gonna do is use
我快速给你们展示一下   

1739
01:12:34,313 --> 01:12:38,182
  this description to fix this
   problem I said right here.
利用 description 来回答我留在这里的问题   

1740
01:12:38,184 --> 01:12:41,385
    Which is what if I had a
     function called learn
定义一个叫 learn 的函数

1741
01:12:41,387 --> 01:12:45,388
  op 'kay and it took an op as
       an argument here.
它把 op 作为参数       

1742
01:12:45,390 --> 01:12:53,029
 And it just said known ops ops
  description equals that op.
knownOps[op.description] = op  

1743
01:12:53,031 --> 01:12:59,368
  You see, now these could all
     just be learn op this.
这些都可以变成 learnOp()     

1744
01:13:00,404 --> 01:13:03,438
  Okay which is a lot nicer, I
  only have to type this thing
这看起来就好多了，我只需要把它敲一次  

1745
01:13:03,440 --> 01:13:05,306
    once, and I just use the
       description here.
我在这里用到了 description       

1746
01:13:05,308 --> 01:13:08,875
  The other thing about this,
 notice where this function is.
 另一点，注意这个函数的位置 

1747
01:13:08,877 --> 01:13:10,143
        Inside the init.
它在 init 内部        

1748
01:13:11,246 --> 01:13:12,545
    Okay you are allowed to
你可以在    

1749
01:13:12,547 --> 01:13:14,513
   put functions inside other
           functions.
一个函数的内部放另一个函数           

1750
01:13:14,515 --> 01:13:17,549
 If this is only called inside
 here, you can put it in here.
如果只在内部被调用，你可以这么做 

1751
01:13:17,551 --> 01:13:20,518
 If if I put it outside in fact
  I'd have a little a problem,
如果我把它放到外部，就会有点小问题  

1752
01:13:20,520 --> 01:13:22,387
  because it would have to be
            private.
它得是 private 的            

1753
01:13:22,389 --> 01:13:26,390
 Because it uses op, and that's
 what this error right here is.
因为它用到了 op，这就是 error 的提示 

1754
01:13:26,392 --> 01:13:29,460
 All right I'd have say private
  func, but I don't want to do
我得把它变成 private 的，但是我不想这么做  

1755
01:13:29,462 --> 01:13:32,462
 private func, instead I'm just
   gonna put this right down
所以我把它放到这里   

1756
01:13:32,464 --> 01:13:35,131
   here, okay and obviously I
    would do that one last.
显然，我得再做一遍

1757
01:13:35,133 --> 01:13:37,333
    Okay that's it, hope you
       learned a lot and
完成了，希望你们能学到很多知识

1758
01:13:37,335 --> 01:13:40,236
 stuff elsewhere for that and I
   will see you on Wednesday,
周三再见

1759
01:13:40,238 --> 01:13:42,037
      I'm here if you have
           questions.
如果有问题来这问我           

1760
01:13:44,074 --> 01:13:47,976
  For more, please visit us at
         stanford.edu.
